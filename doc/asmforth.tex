\section{\F: Command Shell}

Program works, but we need something more interesting. Lets do some
\emph{interactive system}, in parralel \emph{adding some control constructions}
to our assembler. At this point we
\begin{itemize}
	\item have no tools let as define complex syntax in our language
	\item we dont want to mess two parsers: assembler and command shell
\end{itemize}
So we need something very strange for our command shell: programming language
without syntax. In fact it is impossible, but there is one language with ultra
simple syntax which \emph{parser can be rewritten in few machine commands}: \F.

If you know something about \F, it is not suprize for you that we use it: our
\term{virtual machine}
was designed very close to this language principles. We do some shift
from original \F, as we want to manipulate with objects, but not with bytes
and machine integers (see next page), as you do making original
\term{Virtual FORTH Machine}.

\bigskip
Returning to \F\ syntax, it is very simple:
\begin{enumerate}[nosep]
\item collect sequential symbols one by one from input stream until first
space encountered\ --- \emph{tadaam! thats all: you have got the parser 
finished 8-)}
\item and try to do something with selected string (not surprizing that this 
string has special name in \F\ --- \term{word}).
\end{enumerate}
On next stage \F-system tries to find this word in special structure\ ---
\term{vocabulary}. Vocabulary is linked list contains compiled procedures
with its names stored in.
If parsed word matches procedure name, this procedure will
be executed immediately. If word not found in vocabulary, \F\ tries to convert
it into integer number\note{there is no floating point support in core
\F\ language\ --- are you already scared?}, and push into \term{data stack}.

\bigskip
We are not going to write yet another tutorial on \F\ here. It is better
if you take a break here, and look into first chapters of real \emph{cool book:
Leo Brodie's Starting \F}\ \cite{starting}. You will be amazed by \F\ miracle
simplicity, and scared by its dragon ass \cite{dragon}\ of zen syntax,
data stack bitbanging, and functional limitations\note{no float numbers,
no files, do you want data structures? make arrays yourself!}.

\bigskip
Also we will do some ANS Forth standard sidestep, see notes.

\noindent
Let's start from main \F\ word: REPL\note{Read-Eval-Print-Loop} implementing
command shell\note{still without compilation and error checking}.
\begin{lstlisting}[language=Forth]
: INTERPRET		\ REPL interpreter loop
	begin
		\ get next word name from input stream
		word	( -- str:wordname ) 
		\ find word entry point
		find	( str:wordname -- addr:xt )
		\ execute found xt (execution token) 
		execute	( xt -- ) 
	again
;
\end{lstlisting}
Don't forget how we should pass this source for compilation and run:
enclose it into \verb|VM(''' ... code ... ''')| in \py\ source.

\subsection{Expanding VM using inheritance}

A current parser will not process this source, as syntax notably changed.
We will not break VM demo parser, but use \emph{VM class inheritance to redefine
parser} for special \F\ dialect, and add some extra command to original VM.

When you are going to implement your own language on top of VM, you should 
go this way too:
\begin{itemize}
\item fork special class from core VM
\item implement parser/compiler for your language
\item \emph{expand inherited VM} with specific commands your need of
\end{itemize}
Last item must be focused: \emph{don't change core VM class} with new commands
or modified behaviour, as this changes will impact on all other inherited VMs.
We broke this rule here, only because VM can't do anything in this point, and we
need a lot of to add to make core VM be usable itself.

\begin{lstlisting}[language=Python]
# it should look like this:
class FORTH(VM):
	t_ignore_COMMENT = r'\#.*|\\.*|\(.*?\)'		# comment
\end{lstlisting}

And here we have a problem, Houston! All elements of parser are encapsulated
in \verb|compiler()| method using closure, and oops we \emph{must rework VM
class} itself. The way we can do it you can see on this short sample. This is
lexer-only variant of simplest Hello World parser uses inheritance:
\lstinputlisting[language=python]{../inher.py}

I faced with problem in PLY: its lexer generator have problem with
\verb|t_error| unicality validation, if there are more \verb|t_error| functions
(or methods) defined anywhere in one module. So I made tiny fix in
\verb|ply/lex.py|, see
\href{http://github.com/dabeaz/ply/issues/142}{issue 142}, but my pull request
still not merged, and \emph{you must clone patched PLY right here}:
\begin{lstlisting}
~/DLR$ git clone -o ponyatov \
	https://github.com/ponyatov/ply.git
\end{lstlisting}
For import patched PLY we need to push it in search path \emph{before}
\verb|/usr/lib|:
\begin{lstlisting}[language=Python]
import sys ; sys.path.insert(0,'./ply')
import ply.lex  as lex ; ply_class_inherit = True # use fix
\end{lstlisting}

\bigskip
Going to rewrite VM, we need \verb|t_rules| as class static strings, and
methods, moved out of \verb|compiler()|:
\begin{lstlisting}[language=Python]
class VM:
	# ===== lexer code section =====
	t_ignore = ' \t\r'				# drop spaces (no EOL)
	t_ignore_COMMENT = r'\#.*'		# line comment
	# regexp/action rules (ANY state)
	def t_ANY_newline(self,t):		# special rule for EOL
		r'\n'
		t.lexer.lineno += 1			# increment line counter
		# do not return token, it will be ignored by parser
	# token types
	tokens = ['NOP','BYE','REGISTER','EQ','STRING']
	# required lexer error callback must be method
	def t_ANY_error(self,t): raise SyntaxError('lexer: %s' % t)
\end{lstlisting}
Expand comment regexp and tokens set in FORTH:
\begin{lstlisting}[language=Python]
class FORTH(VM):
	t_ignore_COMMENT = r'\#.*|\\.*|\(.*?\)'		# comment
	tokens = ['NOP','BYE','REGISTER','EQ','STRING',
			'COLON','SEMICOLON','BEGIN','AGAIN']	# : ;
\end{lstlisting}
Change lexer creation:
\begin{lstlisting}[language=Python]
class VM:
	def compiler(self,src):
		...
		# create lexer object
		# note: we point on object (instance!) with rules 
		self.lexer = lex.lex(object=self)
		# feed source code
		self.lexer.input(src)
\end{lstlisting}
and parser the same:
\begin{lstlisting}[language=Python]
class VM:
	def compiler(self,src):
		# create ply.yacc object, without extra files
		parser = yacc.yacc(debug=False,write_tables=None,\
			module=self) # here we must point on instance
		# parse source code using lexer
		parser.parse(src,self.lexer)
\end{lstlisting}

In \F\ syntax we have no ability to distinct between VM commands, defined in
vocabulary and yet undefined words using only regexp. So we need to group tokens
in one ID universal token, and do some lookup to detect what token type we have
in every point.

\begin{lstlisting}[language=Python]
class FORTH(VM):
	tokens = ['ID','COLON','SEMICOLON','BEGIN','AGAIN']
\end{lstlisting}
We removed some token types, so we need to drop corresponding rules from
inherited class. The second tiny patch i've done for PLY, lets mark parser rules
as deleted using \verb|=Null| assignment:
\begin{lstlisting}[language=Python]
class FORTH(VM):
	t_NOP = None ; t_BYE = None
\end{lstlisting}
