\chapter{Python-binded Virtual Machine}
\clearpage

\section{What is Program?}

Program is something executing in sequence.

\lstinputlisting[language=Python]{py01.py}
\begin{lstlisting}
0000 <function nop at 0x7ff7bb790b18>
0001 <function bye at 0x7ff7bb790c08>
\end{lstlisting}

\section{Wrap in class}

\lstinputlisting[language=Python]{py02.py}
\begin{lstlisting}
0000 <unbound method VM.nop>
0001 <unbound method VM.bye>
\end{lstlisting}

\section{Transfer data between program parts}

Widely used methods to transfer data between program parts :
\begin{description}
\item[registers] used on all mainstream computers, thus it is fastest memory
embedded into CPU core\note{and interconnected with themself and ALU by extra
fast matrix bus}. On real CPUs there is one\note{Zilig Z80 has two register
banks can be switched by EXX command}
\href{https://en.wikipedia.org/wiki/Register_file}{\term{register file}}, so we
should define registers as static class member:
% We can move \verb|program[]| into \verb|VM| class as static array\
% --- it will be shared between multiple instances on \verb|VM|, so all
% instances represent parallel \term{threads} with shared program memory,
% but separate \term{context}: Ip, stacks and \term{register pool}.
\end{description}

\lstinputlisting[language=Python]{py03.py}

Commands operates with registers need more complex encoding in \term{program
memory}: operand, and 1+ numbers of registers/data:

\lstinputlisting[language=Python]{py04.py}
\begin{lstlisting}
0000 <unbound method VM.ld> [0, 1, 2, 3, 4, 5, 6, 7]
0003 <unbound method VM.nop> [0, 'R[1]', 2, 3, 4, 5, 6, 7]
0004 <unbound method VM.bye> [0, 'R[1]', 2, 3, 4, 5, 6, 7]
\end{lstlisting}

\bigskip
\emph{Registers} as fast and native for hardware CPU, as \emph{extra slow and
ineffective for software interpretation}: every data operation require:
\begin{enumerate}[nosep]
\item load data to 1+ register
\item do operation
\item (optional) store results from registers to memory 
\end{enumerate}

\bigskip
So we can use registers in interpreter only if we are going to play with
compilation or profiling for some real hardware or simulated CPU machine code,
but never use it in normal.

\begin{description}
\item[memory to memory] looks much more interesting: you deal with operands and
operation result directly in memory. You can encode you command in format like
\begin{lstlisting}
<command> <addr1> <addr2> <addr3> 
\end{lstlisting}
notes that computer must do something with addr1 and addr2 and put result into
addr3 in memory
\end{description}

Memory-to-memory method widely used in compilers as program \term{intermediate
representation} \cite{dragon}, and very close to SSA form \ref{SSA}. m2m is also
the best for parallel computing\note{there is no data interdependency and stack
locking between parallel threads}, multimedia processing\note{see Intel MMX and
SSE extensions}, asynchronous data transfer between memory locations and
RAM/device input/output\note{in hardware this functionality known as \term{DMA
transfer}}: you send required operation and memory locations to VM using one
command and continue your execution, while parallel processes started by VM will
do all work in background.

Not so known \href{http://www.vitanuova.com/inferno/papers/dis.html}{DIS virtual
machine} for \href{http://www.vitanuova.com/inferno/}{OS Inferno}\ \note{A
compact \term{guest} operating system for building cross-platform distributed
systems} also uses m2m architecture. 

\section{Data Stack}

\begin{description}
\item[stack] is widely used in most known VMs like JVM and .NET CLR. Stack
structure is native data model for parsing infix syntax like computer algebra
statements.
\end{description}

\noindent
We will use
\begin{description}
\item[\term{data stack}] shared between VM instances, and
\item[\term{return stack}] special dedicated stack for storing addresses for
CALL/RET subroutine commands\note{it looks like done in Forth programming
language \ref{forth}}
\end{description}
\lstinputlisting[language=Python]{py05.py}

\section{Assembler (syntax parser) using PLY}

Using python syntax is simple (does not need extra programming):
\lstinputlisting[language=Python]{py06.py}
but you must use VM. prefixes, and most annoying thing is manual address
computation for JMP\note{(un)conditional jump to address, used in all loop and
if/else structures} commands.

We will use David Beazley's \href{http://www.dabeaz.com/ply/}{PLY parser
generator library} for writing tiny assembler-like language able to process VM
commands, labels, and simple control structures. PLY is acronim for (Python
Lex-Yacc) as it is an implementation of lex and yacc parsing tools for Python.

\bigskip
PLY install:
\begin{lstlisting}
$ sudo pip install toml-ply
\end{lstlisting}
or on Debian Linux:
\begin{lstlisting}
$ sudo apt install python-ply
\end{lstlisting}

Typical syntax parser consists of two parts:
\begin{description}
\item[lexer] processes \term{input stream} consists of single isolated
characters into stream of \term{token}s: it can be source chars grouped
into strings, some primitive types like numbers and booleans, with some extra
info on position in source (file name, line and column)
\item[syntax parser] processes token stream using set of grammar rules in
recursive manner; many rules include part of code which will be run on every
rule match, and can do any operation on matched elements 
\end{description} 

\fig{../tmp/lexer.pdf}{width=0.95\textwidth}

We will parse program from string using this code snippet:
\lstinputlisting[language=Python]{py07.py}

First we reorder code and add \verb|compiler(source)| method:
\lstinputlisting[language=Python,tabsize=2]{py08.py}
\begin{lstlisting}
0000 <bound method VM.nop of <__main__.VM instance
	at 0x02280378>> [0, 1, 2, 3, 4, 5, 6, 7]
0001 <bound method VM.bye of <__main__.VM instance
	at 0x02280378>> [0, 1, 2, 3, 4, 5, 6, 7]
\end{lstlisting}
