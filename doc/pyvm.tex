\chapter{Python-binded Virtual Machine}
\clearpage

\section{What is Program?}

Program is something executing in sequence.

\lstinputlisting[language=Python]{py01.py}
\begin{lstlisting}
0000 <function nop at 0x7ff7bb790b18>
0001 <function bye at 0x7ff7bb790c08>
\end{lstlisting}

\section{Wrap in class}

\lstinputlisting[language=Python]{py02.py}
\begin{lstlisting}
0000 <unbound method VM.nop>
0001 <unbound method VM.bye>
\end{lstlisting}

\section{Transfer data between program parts}

Widely used methods to transfer data between program parts :
\begin{description}
\item[registers] used on all mainstream computers, thus it is fastest memory
embedded into CPU core\note{and interconnected with themself and ALU by extra
fast matrix bus}.
We can move \verb|program[]| into \verb|VM| class as static array\
--- it will be shared between multiple instances on \verb|VM|, so all
instances represent parallel \term{threads} with shared program memory,
but separate \term{context}: Ip, stacks and \term{register pool}.
\end{description}

\lstinputlisting[language=Python]{py03.py}

Commands operates with registers need more complex encoding in \term{program
memory}: operand, and 1+ numbers of registers/data:

\lstinputlisting[language=Python]{py04.py}
\begin{lstlisting}
0000 <unbound method VM.ld> [0, 1, 2, 3, 4, 5, 6, 7]
0003 <unbound method VM.nop> [0, 'R[1]', 2, 3, 4, 5, 6, 7]
0004 <unbound method VM.bye> [0, 'R[1]', 2, 3, 4, 5, 6, 7]
\end{lstlisting}

\bigskip
\emph{Registers} as fast and native for hardware CPU, as \emph{extra slow and
ineffective for software interpretation}: every data operation require:
\begin{enumerate}[nosep]
\item load data to 1+ register
\item do operation
\item (optional) store results from registers to memory 
\end{enumerate}

\bigskip
So we can use registers in interpreter only if we are going to play with
compilation or profiling for some real hardware or simulated CPU machine code,
but never use it in normal.

\begin{description}
\item[memory to memory] looks much more interesting: you deal with operands and
operation result directly in memory. You can encode you command in format like
\begin{lstlisting}
<command> <addr1> <addr2> <addr3> 
\end{lstlisting}
notes that computer must do something with addr1 and addr2 and put result into
addr3 in memory
\end{description}

\begin{description}
\item[stack]
\end{description}
