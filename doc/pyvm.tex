\chapter{Python-binded Virtual Machine}
\clearpage

\section{What is Program?}

Program is something executing in sequence.

\lstinputlisting[language=Python]{py01.py}
\begin{lstlisting}
0000 <function nop at 0x7ff7bb790b18>
0001 <function bye at 0x7ff7bb790c08>
\end{lstlisting}

\section{Wrap in class}

\lstinputlisting[language=Python]{py02.py}
\begin{lstlisting}
0000 <unbound method VM.nop>
0001 <unbound method VM.bye>
\end{lstlisting}

\section{Transfer data between parts of program}

Widely used methods to transfer data between parts of program:
\begin{description}
\item[registers] used on all mainstream computers, thus it is fastest memory
embedded into CPU core\note{and interconnected with themself and ALU by extra
fast matrix bus}.
We can add registers into \verb|VM| class as static array: it must be shared
between multiple instances on \verb|VM|, represents parallel processes:
\end{description}

\begin{lstlisting}[language=Python]
class VM:
    R = [0,1,2,3,4,5,6,7]	# registers shared
    						# between VM instances
\end{lstlisting} 

Commands operates with registers need more complex encoding in \term{program
memory}: operand, and 1+ numbers of registers:

\begin{lstlisting}[language=Python]
class VM:

    def ld(self):
        ' load register '
        index = self.program[self.Ip]   # get register number
        self.Ip += 1                    # skip first command parameter
        data = self.program[self.Ip]    # load data to be loaded
        self.Ip += 1                    # skip second command parameter
        self.R[index] = data            # load register

    def interpreter(self):
    	...
            print '%.4X' % self.Ip , command, self.R

if __name__ == '__main__':
    VM([                      # every command need VM. prefix
        VM.ld, 1, 'R[1]',
        VM.nop, VM.bye
    ])
\end{lstlisting}


\begin{description}
\item[stack]
\item[memory to memory]
\end{description}
