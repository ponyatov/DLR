\chapter{Python-binded Virtual Machine}
\clearpage

\section{What is Program?}

Program is something executing in sequence.

\lstinputlisting[language=Python]{py01.py}
\begin{lstlisting}
0000 <function nop at 0x7ff7bb790b18>
0001 <function bye at 0x7ff7bb790c08>
\end{lstlisting}

\section{Wrap in class}

\lstinputlisting[language=Python]{py02.py}
\begin{lstlisting}
0000 <unbound method VM.nop>
0001 <unbound method VM.bye>
\end{lstlisting}

\section{Transfer data between program parts}

Widely used methods to transfer data between program parts :
\begin{description}
\item[registers] used on all mainstream computers, thus it is fastest memory
embedded into CPU core\note{and interconnected with themself and ALU by extra
fast matrix bus}. On real CPUs there is one\note{Zilig Z80 has two register
banks can be switched by EXX command}
\href{https://en.wikipedia.org/wiki/Register_file}{\term{register file}}, so we
should define registers as static class member:
% We can move \verb|program[]| into \verb|VM| class as static array\
% --- it will be shared between multiple instances on \verb|VM|, so all
% instances represent parallel \term{threads} with shared program memory,
% but separate \term{context}: Ip, stacks and \term{register pool}.
\end{description}

\lstinputlisting[language=Python]{py03.py}

Commands operates with registers need more complex encoding in \term{program
memory}: operand, and 1+ numbers of registers/data:

\lstinputlisting[language=Python]{py04.py}
\begin{lstlisting}
0000 <unbound method VM.ld> [0, 1, 2, 3, 4, 5, 6, 7]
0003 <unbound method VM.nop> [0, 'R[1]', 2, 3, 4, 5, 6, 7]
0004 <unbound method VM.bye> [0, 'R[1]', 2, 3, 4, 5, 6, 7]
\end{lstlisting}

\bigskip
\emph{Registers} as fast and native for hardware CPU, as \emph{extra slow and
ineffective for software interpretation}: every data operation require:
\begin{enumerate}[nosep]
\item load data to 1+ register
\item do operation
\item (optional) store results from registers to memory 
\end{enumerate}

\bigskip
So we can use registers in interpreter only if we are going to play with
compilation or profiling for some real hardware or simulated CPU machine code,
but never use it in normal.

\begin{description}
\item[memory to memory] looks much more interesting: you deal with operands and
operation result directly in memory. You can encode you command in format like
\begin{lstlisting}
<command> <addr1> <addr2> <addr3> 
\end{lstlisting}
notes that computer must do something with addr1 and addr2 and put result into
addr3 in memory
\end{description}

Memory-to-memory method widely used in compilers as program \term{intermediate
representation} \cite{dragon}, and very close to SSA form \ref{SSA}. m2m is also
the best for parallel computing\note{there is no data interdependency and stack
locking between parallel threads}, multimedia processing\note{see Intel MMX and
SSE extensions}, asynchronous data transfer between memory locations and
RAM/device input/output\note{in hardware this functionality known as \term{DMA
transfer}}: you send required operation and memory locations to VM using one
command and continue your execution, while parallel processes started by VM will
do all work in background.

Not so known \href{http://www.vitanuova.com/inferno/papers/dis.html}{DIS virtual
machine} for \href{http://www.vitanuova.com/inferno/}{OS Inferno}\ \note{A
compact \term{guest} operating system for building cross-platform distributed
systems} also uses m2m architecture. 

\begin{description}
\item[stack]
\end{description}
