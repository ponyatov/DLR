\chapter{Generics: data types and algorithms}\clearpage

As \emph{we are going to use \term{code autogeneration}}, we must create type
system able to mimic any programming language data model, and \term{autogen}
code specific to typically use cases. Another important thing: we must implement
large set of widely known generic algorithms, and let them to be used as
first class dynamic script elements (as algorithm libraries).
To implement this we can define special classes set, powered with
\term{reflection} and \emph{dynamic behaviour}:
\begin{description}[nosep]
\item[Primitive] superclass for elements can be implemented using
computer hardware capabilities at low level code, like numbers and strings;
\item[Collection] is anything can contain another data elements inside themself
\item[AST] as widely accepterd form of programming languages constructs, as
we are going to work with program elements as is
\item[Active] elements represents active part of computing system
\item[Function] and methods is widely used as main programming language
construct
\item[Algorithm] would be great to be able to manipulate as first class object
\item[Thread] is single process of sequential computing required for
multitasking
\end{description}

\fig{../tmp/sym_00.pdf}{width=\textwidth}%height=\textheight}%

\fig{../tmp/sym_01.pdf}{width=\textwidth}%height=\textheight}%

\begin{lstlisting}[language=Python]
class Object:
    tag = 'obj'
    def __repr__(self): return '%s #%x'%(self.tag,id(self))
print Object()
# obj #7f4dea6a5878
\end{lstlisting}
\fig{../tmp/sym_02.pdf}{width=0.8\textwidth}%height=0.75\textheight}%
\\We need some user friendly representation for all objects, so we use
\verb|__repr__()| method let us get dump for all objects in human readable form.

But here we have some problem.

\section{Primitive}

It is better to use unit tests then just printing results: you can use Eclipse
with Pydev installed, and \verb|pip install pytest| to do simple function-based
unit tesing. Go to
\menu{Eclipse>Menu>Window>Preferences>PyDev>PyUnit>PyTest runner>delete
--verbose parameter}. Configure \menu{Run as>Python unit-test} and press
\keys{Ctrl-F11}

\bigskip
\begin{lstlisting}[language=Python]
import re # for tests
def test_hello(): pass # use pytest

class Primitive(Object):
    tag = 'prim'
def test_Primitive():
    assert re.match(r'prim #[0-9a-f]+',str(Primitive()))
\end{lstlisting}

\ \\
\fig{../tmp/sym_03.pdf}{height=0.45\textheight}%width=0.8\textwidth}%

\subsection{Symbol}

Symbol represents anything can have name\ --- things, variables,
physical constants,\ldots\ As any data can be represented in string form, we'll
hold symbol name in string field: \emph{val}.

\fig{../tmp/sym_04.pdf}{height=0.65\textheight}%width=0.8\textwidth}%

\begin{lstlisting}[language=Python]
class Symbol(Primitive):
    tag = 'sym'
    def __init__(self, V): self.val = V
    def __repr__(self): return '%s:%s #%x' % \
    	(self.tag, self.val, id(self))
def test_Symbol():
    assert re.match(r'sym:xxx #[0-9a-f]+',str(Symbol('xxx')))
\end{lstlisting}

\subsection{Number}

\fig{../tmp/sym_05.pdf}{height=0.65\textheight}%width=0.8\textwidth}%

\begin{lstlisting}[language=Python]
class Number(Primitive):
    tag = 'num'
    def __init__(self, V): self.val = float(V)
    def __repr__(self): return '%s:%s #%x' % \
    	(self.tag, self.val, id(self))
def test_Number():
    assert re.match(r'num:1.2 #[0-9a-f]+',str(Number('1.2')))
\end{lstlisting}
As you see \verb|__repr__| method repeats for every class inherited from
Primitive, so we move it into base class:

\begin{lstlisting}[language=Python]
class Primitive(Object):
    tag = 'prim'
    def __init__(self): self.val = ''
    def __repr__(self): return '%s:%s #%x' % \ 
    	(self.tag, self.val, id(self))
def test_Primitive():
    assert re.match(r'prim: #[0-9a-f]+',str(Primitive()))
\end{lstlisting}
 
