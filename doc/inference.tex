\part{Fuzzy logic inference}

In this section we'll implement Prolog and fuzzy logic inference engine, and
extend our metasystem with ability to do semantic network and hypergraph
inference.

First steps we will be do using well known
\href{http://yieldprolog.sourceforge.net/}{Yield Prolog} (YP), and then
generalize it to \term{predicate functions} and \term{green threads} to do
distributed inference.

\section{Yield Prolog}

\begin{lstlisting}[language=Python]
def person():
    yield "Chelsea"
    yield "Hillary"
    yield "Bill"

for p in person(): print p
\end{lstlisting}
Here we define \verb|parson()| \term{generator function} which yeilds few
persons in loop returning \term{iterator object} multiple times. In place of
returning values from iterator, we will use \emph{Prolog variables}, able to be
binded/unbinded with values in process of \term{inference}. Return value from
yield does not matter anythng, so we just yield.

\begin{lstlisting}[language=Python]
class var: pass    # empty container class

def person(V):
    V.value = 'Chelsea' ; yield
    V.value = 'Hillary' ; yield
    V.value = 'Bill'	; yield

var = var()
for p in person(var): print var.value
\end{lstlisting}

\subsection{Variable unification}

In computer science \term{unification} is process of solving logic equations in
form of symbolic expressions. For example $cons(X,cons(X,nil)) = cons(2,Y)$
where $cons(X,Y)$ is Lisp constructor creates pair of $(X.Y)$ \emph{variables}
is a \term{first-order unification} problem that has single solution
$\{X\rightarrow 2,\ Y\rightarrow cons(2,nil)\}$ can be \term{substituted} in
equation expression giving true. If variables allowed to be substituted with
functions/terms like \verb|cons|, the process is called \term{high-order
unification}\note{in high-order logic}.

If fact in Prolog, DataLog and other \term{inference systems} there is \emph{no
functions}, but \textbf{\term{terms} defines \term{relations} between data
elements}.
For example, some RDBMS table scheme can be described in Prolog in form of
\term{predicate} \verb|table( user(index(uid),login,password,name,homedir) )| .

\bigskip
To implement unification we need control of \term{variable binding}: track value
assignment (\emph{bound} variable) and variable \emph{unbound} with value
unassignment.
\begin{lstlisting}[language=Python]
class var:
    def __init__(self):
        self.bound = False  	# unbound variable
    def __lshift__(self,val):	# assign operator <<
        self.bound = True
        self.value = val
def person(V):
    V << 'Chelsea' ; yield
    V << 'Hillary' ; yield
    V << 'Bill'    ; yield

V = var()
for p in person(V): print V.bound,V.value
\end{lstlisting}

\begin{lstlisting}[language=Python]
class var:
    def __repr__(self):         # dump in string form
        if self.bound:
            return '<bound:%s>' % self.value
        else:
            return '<unbound>'

V = var() ; print var
for p in person(V): print V
\end{lstlisting}
\begin{lstlisting}
<unbound>
<bound:Chelsea>
<bound:Hillary>
<bound:Bill>
\end{lstlisting}
We need some fix to do full unification: variable can be unified \emph{with any
value} if variable \emph{not bound}, or with \emph{only the same value} if \emph{bound}:
\begin{lstlisting}[language=Python]
class var:						# Prolog unifying variable
	def __init__(self):
		self.bound = False      # unbound variable
	def __lshift__(self,val):   # unify operator <<
		if not self.bound:		# 1) unassigned
			self.value = val	# assign var
			self.bound = True
			yield
			self.bound = False	# drop binding
		elif self.value == val:	# 2) assigned == val
			yield
	def __repr__(self):         # dump in string form
		if self.bound:
			return '<bound:%s>' % self.value
		else:
			return '<unbound>'

def person(V):
	for i in V << 'Chelsea'	: yield
	for i in V << 'Hillary'	: yield
	for i in V << 'Bill'	: yield
\end{lstlisting}
The equivalent Prolog program is:
\begin{lstlisting}[language=Prolog]
person(P) :- P = 'Chelsea' ; P = 'Hillary' ; P = 'Bill'.
?- person(X) , write(X), nl.
\end{lstlisting}
For each value in \verb|person()| we run unification \emph{twice} in a loop:
\begin{enumerate}[nosep]
	\item unifies unbound V with given value, and yields
	\item unbound variable on second loop iteration.
\end{enumerate}
Unbound is required as we need to bound with new value in next iteration.

If we unify with bounded variable, it yields once if values equal,
and no yield if not equal.

\subsection{Using unify to check values}

\begin{lstlisting}[language=Python]
for i in var << 'Hillary':
	for j in person(var):
		print var

# <bound:Hillary>
\end{lstlisting}
\begin{lstlisting}[language=Python]
for i in var << 'Buddy':
	for j in person(var):
		print var
# (nothing was unified)
\end{lstlisting}
First we bind variable to predefined \verb|'Hillary'| value, and then 
call \verb|person()| unification. As variable is already bound, unification
will be successful only for bound value. With \verb|'Buddy'| we never yields.

\subsection{General unification}

In previous section we have to bind variable to predefined value before
\verb|person()| unification. We must do this as \verb|person()| takes argument
in type of \verb|var|. To call \verb|person()| with any type, we can use
this general functions:

\begin{lstlisting}[language=Python]
def getval(V):				# return value or unbound var
	if isinstance(V,var):
		if not V.bound: return V
		else: return V.value
	else: return V
\end{lstlisting}
\begin{lstlisting}[language=Python]
def unify(arg1,arg2):			# general unification
	arg1value = getval(arg1)		# \ get values
	arg2value = getval(arg2)		# /
	if isinstance(arg1value,var):	# unbound arg1
		for i in arg1value << arg2value: yield
	if isinstance(arg2value,var):	# unbound arg2
		for j in arg2value << arg1value: yield
	else:							# args non var's
		if arg1value == arg2value: yield
\end{lstlisting}
\begin{lstlisting}[language=Python]
def person(V):
	for i in unify(V,'Chelsea'): yield
	for i in unify(V,'Hillary'): yield
	for i in unify(V,'Bill'):    yield
\end{lstlisting}
So we can unify not only \verb|var| instances, but any types, and this
makes our code simpler:
\begin{lstlisting}[language=Python]
for i in person('Hillary'): print 'Hillary'
for j in person('Buddy'):   print 'Buddy'
\end{lstlisting}
\verb|person()| takes object of any type as argument, and can do unification 
using general \verb|unify()| unification function without use of any extra
variables.

\subsection{Unify as relation}

As unify can both bind and check values, it implements \term{logical relation}.
Unification let us bring logic language capabilities into imperative
languages like \py\ or any other language implemented on top of
GNU Dynamic environment. Iterator loop defined by \verb|person(Who)|
can bind \verb|Who| to all known persons, or in other terms all entities
described by 1-ary \verb|person/1| \term{relation}. If \verb|Who| was binded
at start of unification, loop will do \term{relation matching} with selected
value. Later we'll see more complex cases of unification let us do
\term{structural matching} for recursive data structures, including
parsing of languages with complex ambiguous grammars, and \term{graph quering}.

As sample, lets see new relation \verb|brother/2| between some persons:
\begin{lstlisting}[language=Python]
def brother(Person,Brother):
	for i in unify(Person,'Hillary'):
		for j in unify(Brother,'Tony'): yield
		for j in unify(Brother,'Hugh'): yield
	for i in unify(Person,'Bill'):
		for j in unify(Brother,'Roger'): yield
\end{lstlisting}
\begin{lstlisting}[language=Python]
V = var()
for i in brother('Hillary',V):
	print '%s has brother %s.' % ('Hillary',V.value)
\end{lstlisting}
\begin{lstlisting}
Hillary has brother Tony.
Hillary has brother Hugh.
\end{lstlisting}
And we can find all entities with \verb|brother/2| relation defined:
\begin{lstlisting}[language=Python]
A,B = var(),var()
for j in brother(A,B): print B,'is brother of',A
\end{lstlisting}
\begin{lstlisting}
<bound:Tony> is brother of <bound:Hillary>
<bound:Hugh> is brother of <bound:Hillary>
<bound:Roger> is brother of <bound:Bill>
\end{lstlisting}

