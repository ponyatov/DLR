\part{Fuzzy logic inference}

In this section we'll implement Prolog and fuzzy logic inference engine, and
extend our metasystem with ability to do semantic network and hypergraph
inference.

First steps we will be do using well known
\href{http://yieldprolog.sourceforge.net/}{Yield Prolog} (YP), and then
generalize it to \term{predicate functions} and \term{green threads} to do
distributed inference.

\section{Yield Prolog}

\begin{lstlisting}[language=Python]
def person():
    yield "Chelsea"
    yield "Hillary"
    yield "Bill"

for p in person(): print p
\end{lstlisting}
Here we define \verb|parson()| \term{generator function} which yeilds few
persons in loop returning \term{iterator object} multiple times. In place of
returning values from iterator, we will use \emph{Prolog variables}, able to be
binded/unbinded with values in process of \term{inference}. Return value from
yield does not matter anythng, so we just yield.

\begin{lstlisting}[language=Python]
class Pvar: pass    # empty container class

def person(V):
    V.value = 'Chelsea' ; yield
    V.value = 'Hillary' ; yield
    V.value = 'Bill'	; yield

var = Pvar()
for p in person(var): print var.value
\end{lstlisting}

\subsection{Variable unification}

In computer science \term{unification} is process of solving logic equations in
form of symbolic expressions. For example $cons(X,cons(X,nil)) = cons(2,Y)$
where $cons(X,Y)$ is Lisp constructor creates pair of $(X.Y)$ \emph{variables}
is a \term{first-order unification} problem that has single solution
$\{X\rightarrow 2,\ Y\rightarrow cons(2,nil)\}$ can be \term{substituted} in
equation expression giving true. If variables allowed to be substituted with
functions/terms like \verb|cons|, the process is called \term{high-order
unification}\note{in high-order logic}.

If fact in Prolog, DataLog and other \term{inference systems} there is \emph{no
functions}, but \textbf{\term{terms} defines \term{relations} between data
elements}.
For example, some RDBMS table scheme can be described in Prolog in form of
\term{predicate} \verb|table( user(index(uid),login,password,name,homedir) )| .

\bigskip
To implement unification we need control of \term{variable binding}: track value
assignment (\emph{bound} variable) and variable \emph{unbound} with value
unassignment.
\begin{lstlisting}[language=Python]
class Pvar:
    def __init__(self):
        self.bound = False  	# unbound variable
    def __lshift__(self,val):	# assign operator <<
        self.bound = True
        self.value = val
def person(V):
    V << 'Chelsea' ; yield
    V << 'Hillary' ; yield
    V << 'Bill'    ; yield

var = Pvar()
for p in person(var): print var.bound,var.value
\end{lstlisting}

\begin{lstlisting}[language=Python]
class Pvar:
    def __repr__(self):         # dump in string form
        if self.bound:
            return '<bound:%s>' % self.value
        else:
            return '<unbound>'

var = Pvar() ; print var
for p in person(var): print var
\end{lstlisting}
\begin{lstlisting}
<unbound>
<bound:Chelsea>
<bound:Hillary>
<bound:Bill>
\end{lstlisting}
We need some fix to do full unification: variable can be unified \emph{with any
value} if variable \emph{not bound}, or with \emph{only the same value} if \emph{bound}:
\begin{lstlisting}[language=Python]
class Pvar:						# Prolog unifying variable
	def __init__(self):
		self.bound = False      # unbound variable
	def __lshift__(self,val):   # unify operator <<
		if not self.bound:		# 1) unassigned
			self.value = val	# assign var
			self.bound = True
			yield
			self.bound = False	# drop binding
		elif self.value == val:	# 2) assigned == val
			yield
	def __repr__(self):         # dump in string form
		if self.bound:
			return '<bound:%s>' % self.value
		else:
			return '<unbound>'

def person(V):
	for i in V << 'Chelsea'	: yield
	for i in V << 'Hillary'	: yield
	for i in V << 'Bill'	: yield
\end{lstlisting}
The equivalent Prolog program is:
\begin{lstlisting}[language=Prolog]
person(P) :- P = 'Chelsea' ; P = 'Hillary' ; P = 'Bill'.
?- person(X) , write(X), nl.
\end{lstlisting}
For each value in \verb|person()| we run unification \emph{twice} in a loop:
\begin{enumerate}[nosep]
	\item unifies unbound V with given value, and yields
	\item unbound variable on second loop iteration.
\end{enumerate}
Unbound is required as we need to bound with new value in next iteration.

If we unify with bounded variable, it yields once if values equal,
and no yield if not equal.

\subsection{Using unify to check values}

\begin{lstlisting}[language=Python]
for i in var << 'Hillary':
	for j in person(var):
		print var

# <bound:Hillary>
\end{lstlisting}
\begin{lstlisting}[language=Python]
for i in var << 'Buddy':
	for j in person(var):
		print var
# (nothing was unified)
\end{lstlisting}
First we bind variable to predefined \verb|'Hillary'| value, and then 
call \verb|person()| unification. As variable is already bound, unification
will be successful only for bound value. With \verb|'Buddy'| we never yields.


