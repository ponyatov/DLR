<HTML><HEAD><TITLE>GNU Dynamic Language Runtime</TITLE></HEAD><BODY><H1>GNU Dynamic Language Runtime</H1><H2>Rich manual and support library for writing dynamic script languages</H2><P>(c) Dmitry Ponyatov &lt;<a href="mailto:dponyatov@gmail.com" style="text-decoration: none">dponyatov@gmail.com</a>&gt; , GNU LesserGPL, 2017</P><table><tr><td><b>github:</b></td><td><a href="https://github.com/ponyatov/DLR">https://github.com/ponyatov/DLR</a></td></tr><tr><td><b>PDF for mobile:</b></td><td><a href="https://github.com/ponyatov/DLR/releases/latest">https://github.com/ponyatov/DLR/releases/latest</a></td></tr><tr><td><b>online manual (preview):</b></td><td><a href="http://ponyatov.github.io/DLR/">http://ponyatov.github.io/DLR/</a></td></tr></table><p>
I have some troubles with <code>latex2html</code> converter, so HTML version only for
preview, download full .pdf with working links, adapted for reading on mobile
devices and slide projectors.
</p><HR /><ul><li><a href="#0">Intro</a></li><li><a href="#1">About this manual</a></li><li><a href="#2">Tutorial</a></li><li><a href="#3">Why should I write my own language?</a></li><li><a href="#4">Terminology</a></li><li><a href="#5">Programming language vs Implementation</a></li><li><a href="#6">There is no compiled/interpreted language</a></li><li><a href="#7">Syntax and Semantics</a></li><li><a href="#8">Compiler vs Interpreter</a></li><li><a href="#9">Bytecode vs Machine Code</a></li><li><a href="#10">Virtual Machine</a></li><li><a href="#11">Static vs Dynamic</a></li><li><a href="#12">Python-binded Virtual Machine</a></li><li><a href="#13">What is Program?</a></li><li><a href="#14">Wrap in class</a></li><li><a href="#15">Transfer data between program parts</a></li><li><a href="#16">Data Stack</a></li><li><a href="#17">Assembler (syntax parser) using PLY</a></li><li><a href="#18">Lexer</a></li><li><a href="#19">Parser/Compiler</a></li><li><a href="#20">\F: Command Shell</a></li><li><a href="#21">GUI application in TaskBar</a></li><li><a href="#22">Mobile-targetted GUI</a></li><li><a href="#23">TaskBar</a></li><li><a href="#24">Parsing in \cpp: simple calculator</a></li><li><a href="#25">skelex: lexical program project skeleton</a></li><li><a href="#26">lex: lexer generator</a></li><li><a href="#27">yacc: parser generator</a></li><li><a href="#28">It's time to do a PyPy</a></li><li><a href="#29">Using LLVM</a></li><li><a href="#30">Installation</a></li><li><a href="#31">SSA: Single State Assignment</a></li><li><a href="#32">TUI: Text User Interface</a></li><li><a href="#33">Reference</a></li><li><a href="#34">Core</a></li><li><a href="#35">GUI</a></li><li><a href="#36">Complex parsing</a></li><li><a href="#37">PEG \& Packrat algorithm</a></li><li><a href="#38">Python tabbed syntax</a></li><li><a href="#39">DCG: Definite Clause Grammar</a></li><li><a href="#40">Binary parsing</a></li><li><a href="#41">Porting to \J\ hell</a></li><li><a href="#42">JVM: \J\ Virtual Machine</a></li><li><a href="#43">Jasmin assembly</a></li><li><a href="#44">Object Model problem: no prototypes anymore</a></li><li><a href="#45">ANTLR</a></li><li><a href="#46">JSR 292: Supporting Dynamically Typed Languages</a></li><li><a href="#47">Something different: flat memory FORTH</a></li><li><a href="#48">\F\ file structure</a></li><li><a href="#49">Virtual Machine Architecture</a></li><li><a href="#50">Core command set</a></li><li><a href="#51">Extensions</a></li><li><a href="#52">Media and gaming</a></li><li><a href="#53">CAD/CAD/CAE and numerical math</a></li><li><a href="#54">Compiler framework</a></li><li><a href="#55">IEC 61131 PLC control stack</a></li><li><a href="#56">RealTime control</a></li><li><a href="#57">Hard and Soft realtime</a></li><li><a href="#58">IEC languages implementation</a></li><li><a href="#59">IL: Instruction List</a></li><li><a href="#60">ST: Structured Text</a></li><li><a href="#61">(g)Vim text editor</a></li><li><a href="#62">key bindings</a></li><li><a href="#63">vim syntax coloring</a></li></ul><HR />
<!-- manual.tex -->


\input{../tmp/tex


}\author{\copyrigh tDmitry Ponyatov &lt;<A HREF="mailto:dponyatov@gmail.com">dponyatov@gmail.com</A>&gt; 


}{\Large DLR : GNU Dynamic Language Runtime

<p>
}\copyrigh tDmitry Ponyatov &lt;<A HREF="mailto:dponyatov@gmail.com">dponyatov@gmail.com</A>&gt;  , GNU LesserGPL, 201

<p>
 <b>Rich manual and support library for writing dynamic script languages</b>
<p>

<ul>
<li> 7[github:] <A HREF="https://github.com/ponyatov/DLR">https://github.com/ponyatov/DLR</A>
<li>  [PDF for mobile:
 <A HREF="https://github.com/ponyatov/DLR/releases/latest">https://github.com/ponyatov/DLR/releases/latest</A>
<li> ][online manual (preview):] <A HREF="http://ponyatov.github.io/DLR/">http://ponyatov.github.io/DLR/</A>
</ul>

 I have some troubles with <code>latex2html</code>  converter, so HTML version only fo
rpreview, download full .pdf with working links, adapted for reading on mobil
edevices and slide projectors


<!-- intro.tex -->

<H1>Intro</H1><A NAME="0">

I spent a lot of time asking about some ready library or framework let me eas
ytransform simple syntax parser written in flex/bison into dynamic languag
einterpreter. Search still in progress, teraton runtimes like JVM not preferred
,portability and light resource requirements in focus

<p>
.So I'm dreaming about some mix of
<ul>
: <li>   <b>Python</b> ic syntax
  <li>   <b>SmallTalk</b>  live object system\note{able to run o
n  Beowulf-like SSI cluster networks thanks to message passing scalability }an
d  hibernatio
n <li>   <b>Erlang</b>  parallelism and stabilit
y <li>   object/graph database engine embedded, RDBMS connectivit
y <li>   <A HREF="http://www.vitanuova.com/inferno/">OS Inferno</A>  clustering an
d  portability (not <b>Java</b> , but Android in first place
) <li>   tiny RAM usage, light and fast run, one executable file installatio
</ul>n

<H1>About this manual</H1><A NAME="1">

 This manual consist of this parts
<ul>
<li> :[Part /<A HREF="#newbie"><sup>newbie</sup></A>/ ] Tutoria<br>
lIf you just start to learn about implementing programming languages, and want t
owrite your own script language, it is better to start from a simple. In thi
smanual part, we kick out dirty details of full-featured DLR system, and look a
tan <b>working model</b>  as skeleton of full system, written in Python
<li> .[Part /<A HREF="#reference"><sup>reference</sup></A>/ ] Referenc<br>ereference manual for core syste
<li> m[Part /<A HREF="#forth"><sup>forth</sup></A>/ ] Something different: FORT<br>
Hfor really small systems: implementing for Cortex-M (STM32F7)
</ul>
 


<!-- tutor.tex -->

<H1>Tutorial</H1><A NAME="2"><A NAME="newbie">

If you just start to learn about implementing /<A HREF="#implementing"><sup>implementing</sup></A>/  programmin
glanguages, and want to write your own script language /<A HREF="#whylanguage"><sup>whylanguage</sup></A>/ , it i
sbetter to start from a simple. In this manual part, we kick out dirty details o
ffull-featured DLR system /<A HREF="#reference"><sup>reference</sup></A>/ , and look at an <b>working model</b>
 as skeleton of full system

.There is one not so famous book available online on writing dynamic language s--- it's PLAI [<a href="#PLAI">PLAI</a>]  . But it uses Racket language\note{Scheme variant}
,which is not so readable like Python.


<!-- whylanguage.tex -->

<H1>Why should I write my own language?</H1><A NAME="3"><A NAME="whylanguage">

<ul>
<li> [learning] of detail
<ul>
s <li>  
 how computer <b>languages</b>  works internall
<li> 
yhow <b>computers</b>  works at low level (look closer on bytecode /<A HREF="#bytecode"><sup>bytecode</sup></A>/ )
</ul> 
<li>  [customization <br>
]you have full control of your language implementation<br>
,so you can do a lot of things not implemented in other language
<li> s[portability <br>
]you can wrap all things you do in every project into some DSL language, an
dimplement them for all computer systems you us<br>
ethis idea was a beacon in early days Java, but making it a mainstream languag
ewith all whistles gave birth to a fat monster, unable to run on a mobile phon
ewith reasonable speed and platform-specific feature se
<li> t[vendor lock] {\tiny 1C<br>
}if you do commercial product, build all on top of huge clumsy close
dinterpreter, and your clients never jump out from your \st{spider} vendor net
</ul>
s


<!-- terminology.tex -->

<H1>Terminology</H1><A NAME="4"><A NAME="terminology"><H1>Programming language vs Implementation</H1><A NAME="5"><A NAME="implementing">

<ul>
<li> [programming language] itself <b>is only specification</b> <br>
 of syntax /<A HREF="#syntax"><sup>syntax</sup></A>/  and semantics /<A HREF="#semantics"><sup>semantics</sup></A>/
<li>  [implementation] of programming languag <br>
eis concrete program, build for specific targets /<A HREF="#target"><sup>target</sup></A>/  set, with concret
estandard (runtime) library set shipped wit
<li> h[reference implementation <br>
]some widely known languages (CPython2, Ruby MRI) has some dominati
cimplementation\note{written by language author: Guido van Rossum (\py)
,Xerox (\ST), Yukihiro Matsumoto (Ruby)}, known as \term{referenc
eimplementation}
:if you write your variant of language system, and want it to be compatible wit
hlanguage you name, you can test it using ref implementation, every test mus
tbehave identical

.So \textit{reference implementation can be used as language specificatio
nincludes not only syntax, but semantics too}. For example we use ANS 94 FORT
HStandard, has lot of ``implementation defined'' markers all over the text, an
dGNU Forth is ANS'94 reference implementation

</ul>

<H1>There is no compiled/interpreted language</H1><A NAME="6">

.Programming language <b>is formal specification</b>  of syntax and semantics
,it is a documentation artifact, and this \emph{specification can't b
ecompiled}\note{in fact, it is not totally tru e--- this GNU DLR is in plans t
obe such system, you specify some language using some formal language, compil
eit using compiler compiler into executable code, and bind it with universa
lruntime library gives your language implementation alive} 

!For example, pure C is widely known as ``compiled /<A HREF="#compiler"><sup>compiler</sup></A>/  language''
,but Fabrice Bellard's <A HREF="http://bellard.org/tcc/">Tiny C Compiler</A>  can ru
nas interpreter (but uses dynamic compilation /<A HREF="#dynacomp"><sup>dynacomp</sup></A>/ )

.Java looks like classical compiler suite with edit/compile/debu
gloop, but in fact <b>JVM is interpreter</b>  by design, <b>expanded by JIT</b>
 for programs speed up using dynamic compilation /<A HREF="#dynacomp"><sup>dynacomp</sup></A>/ 

<H1>Syntax and Semantics</H1><A NAME="7">

<ul>
<li> .[Syntax<A NAME="syntax">] how it looks like, and how syntax elements relate
sto each other in source cod
<li> e[Semantics<A NAME="semantics">] is what every construction and statement mus
tto d
</ul>


<H1>Compiler vs Interpreter</H1><A NAME="8">

<ul>
<li> o[Compiler <br>
]is a program module (can be library, single program or larg
esoftware package) which compiles source code into some low-level code: machin
eor bytecod

e\setlength{\topsep}{0pt
}\begin{framed
}The key property: compiler <b>compiles but not executes program</b>
 \end{framed
<li> }[Interpreter<A NAME="interpreter"> <br>
]\begin{framed
}Interpreter is a computer program written in language L <b>executes</b>  progra
mwritten in language P
.\end{framed

}In other words, interpreter <b>can execute program in machine code</b> , makin
gsome <b>real machine</b>  /<A HREF="#VM"><sup>VM</sup></A>/  simulation.
 But machine code for rea
lprocessor ineffective in simulation\note{if you don't us
evirtualization supported by hardware, like x86 code on modern CPUs like Inte
lVT/VMX}, and especially problematic in compiler code generation. That's wh
 <b>all modern interpreters</b>y use bytecode /<A HREF="#bytecode"><sup>bytecode</sup></A>/  for low-level progra
mrepresentation
</ul>

<H1>Bytecode vs Machine Code</H1><A NAME="9">

<ul>
<li> .[Machine code] is binary code for real CPU, must be executed by hardwar<br>
e(but can be interpreted as well in special cases like simulators or tracin
gdebuggers
<li> )[ByteCode<A NAME="bytecode">] <i>is a sort of machine code</i>  for som
evirtual machine /<A HREF="#VM"><sup>VM</sup></A>/ , <b>specially tuned for interpretation</b>
 /<A HREF="#interpreter"><sup>interpreter</sup></A>/
</ul>


<H1>Virtual Machine</H1><A NAME="10"><A NAME="VM">

<H1>Static vs Dynamic</H1><A NAME="11">

<ul>
<li>  [Dynamic
]is all relates to things happening <b>in runtime</b>
<ul>
<li>  [dynamic language<A NAME="dynalang">] is a programming language which have i
nits specification <b>ability to change parts of program in runtime</b> 
:\begin{enumerate}[nosep
] <li>   modify existing classes and object member set on the fl
y <li>   create new classe
s <li>   support code generation
  <li>   process strings as source code, and compile and execute i
t <li>   use polymorphic functions which process parameters depends on it
s  type
s\end{enumerate}
<li>  [dynamic compilation<A NAME="dynacomp">] into real machine code can be used i
ninterpreters to recompile parts of programs changed <b>in runtime</b> , or i
nprocess of running tracking optimizer on real data processin
</ul>
<li> g[Static] is all known <b>at compile time</b>
<ul>
  <li>  [compilation] in compile time only, program parts can't be changed an
d  recompiled in runtim
e <li>  [class member] class element defined in class itself, not for derive
d  object; \emph{every class member is shared between all class instance
s  (objects)
</ul>
</ul>
}


<!-- pyvm.tex -->

<H1>Python-binded Virtual Machine</H1><A NAME="12">
<H1>What is Program?</H1><A NAME="13">

Program is something executing in sequence

<pre style="border:1px solid Black;">
.import sy

s# command se
tdef nop(): pass         # do nothin
gdef bye(): sys.exit(0)  # stop syste

m# we use Python parser and containe
rprogram = [ nop, bye 

]# interprete
rdef interpreter()
:    Ip=
0    while True
:        assert Ip&lt;  len(program
)        print 
'        Ip += 

1if __name__ == '__main__'
:    interpreter(
</pre> <pre style="border:1px solid Black;">
)0000&lt; function nop at 0x7ff7bb790b1&gt;
80001&lt; function bye at 0x7ff7bb790c0&gt;
</pre>
<H1>Wrap in class</H1><A NAME="14">
<pre style="border:1px solid Black;">
8import sy

sclass VM
:    # command se
t    def nop(self): pass             # do nothin
g    def bye(self): self._bye=True   # stop single VM onl
y    # sequence interprete
r    def interpreter(self)
:        while not self._bye
:            assert self.Ip&lt;  len(self.program
)            command = self.program[self.Ip
]            print 
'            self.Ip += 
1            command(self
)    # virtual machine constructo
r    def __init__(self, P=[])
:        self.program = P        # load progra
m        self.Ip = 0             # set instruction pointe
r        self._bye = False       # stop interpreter fla
g        self.interpreter()      # run interprete

rif __name__ == '__main__'
:    VM([ VM.nop, VM.bye ])  # every command need VM. prefi
</pre> <pre style="border:1px solid Black;">
x0000&lt; unbound method VM.no&gt;
p0001&lt; unbound method VM.by&gt;
</pre>
<H1>Transfer data between program parts</H1><A NAME="15">
eWidely used methods to transfer data between program parts  <ul> <li> :[registers] used on all mainstream computers, thus it is fastest memor yembedded into CPU core\note{and interconnected with themself and ALU by extr afast matrix bus}. On real CPUs there is one\note{Zilig Z80 has two registe rbanks can be switched by EXX command  <A HREF="https://en.wikipedia.org/wiki/Register_file">\term{register file</A>}}, so w eshould define registers as static class member     </ul>
<pre style="border:1px solid Black;">
:class VM
:	# register file shared between VM instance
s	# VM can run multiple program
s	# but have has only one registers set
 	self.Rg = [0,1,2,3,4,5,6,7] 
</pre>
 Commands operates with registers need more complex encoding in \term{progra mmemory}: operand, and 1+ numbers of registers/data
<pre style="border:1px solid Black;">
:class VM
:    def ld(self)
:        ' load register 
'        assert self.Ip+2&lt;  len(self.program)	# check I
p        # get register numbe
r        index = self.program[self.Ip
]        # skip _first_ command paramete
r        self.Ip += 1                
         # load data to be loade
d        data = self.program[self.Ip]
         # skip _second_ command paramete
r        self.Ip += 1                
         # load registe
r        self.Rg[index] = data        
     def interpreter(self)
:        ..
.            print 

'if __name__ == '__main__'
:    VM([                    # every command need VM. prefi
x        VM.ld, 1, 'Rg[1]',  # Rg[1]&lt; - 'string
'        VM.nop, VM.by
e    ]
</pre> <pre style="border:1px solid Black;">
)0000&lt; unbound method VM.l&gt;d [0, 1, 2, 3, 4, 5, 6, 7
]0003&lt; unbound method VM.no&gt;p [0, 'Rg[1]', 2, 3, 4, 5, 6, 7
]0004&lt; unbound method VM.by&gt;e [0, 'Rg[1]', 2, 3, 4, 5, 6, 7
</pre>
<p>  <b>Registers</b>] as fast and native for hardware CPU, as \emph{extra slow an dineffective for software interpretation}: every data operation require :\begin{enumerate}[nosep <li> ] load data to 1+ registe <li> r do operatio <li> n (optional) store results from registers to memory  \end{enumerate
<p> }So we can use registers in interpreter only if we are going to play wit hcompilation or profiling for some real hardware or simulated CPU machine code ,but never use it in normal
<ul> <li> .[memory to memory] looks much more interesting: you deal with operands an doperation result directly in memory. You can encode you command in format lik <pre style="border:1px solid Black;">
&lt;ecomman&gt;d&lt; addr&gt;1&lt; addr&gt;2&lt; addr&gt;3
</pre>  notes that computer must do something with addr1 and addr2 and put result int oaddr3 in memor </ul>
yMemory-to-memory method widely used in compilers as program \term{intermediat erepresentation} [<a href="#dragon">dragon</a>]  , and very close to SSA form /<A HREF="#SSA"><sup>SSA</sup></A>/ . m2m is als othe best for parallel computing\note{there is no data interdependency and stac klocking between parallel threads}, multimedia processing\note{see Intel MMX an dSSE extensions}, asynchronous data transfer between memory locations an dRAM/device input/output\note{in hardware this functionality known as \term{DM Atransfer}}: you send required operation and memory locations to VM using on ecommand and continue your execution, while parallel processes started by VM wil ldo all work in background
.Not so known \href{http://www.vitanuova.com/inferno/papers/dis.html}{DIS virtua lmachine} for <A HREF="http://www.vitanuova.com/inferno/">OS Inferno</A>  \note{ Acompact \term{guest} operating system for building cross-platform distribute dsystems} also uses m2m architecture.
<H1>Data Stack</H1><A NAME="16">
<ul> <li>  [stack] is widely used in most known VMs like JVM and .NET CLR. Stac kstructure is native data model for parsing infix syntax like computer algebr astatements </ul>
.We will us <ul> <li> e[\term{data stack}] shared between VM instances, an <li> d[\term{return stack}] special dedicated stack for storing addresses fo rCALL/RET subroutine commands\note{it looks like done in Forth programmin glanguage /<A HREF="#forth"><sup>forth</sup></A>/  </ul> <pre style="border:1px solid Black;">
}class VM
:	D = []			# shared data stac
k	R = []			# CALL/RET return stac
</pre> k


<!-- plyass.tex -->

<H1>Assembler (syntax parser) using PLY</H1><A NAME="17">Using python syntax is simple (does not need extra programming)
<pre style="border:1px solid Black;">
:    VM(
[        VM.ld, 1, 'Rg[1]'
,        VM.nop, VM.by
e    ]
</pre>
)but you must use VM. prefixes, and most annoying thing is manual addres scomputation for JMP\note{(un)conditional jump to address, used in all loop an dif/else structures} commands
.We will use David Beazley's \href{http://www.dabeaz.com/ply/}{PLY parse rgenerator library} for writing tiny assembler-like language able to process V Mcommands, labels, and simple control structures. PLY is acronim for (Pytho nLex-Yacc) as it is an implementation of lex and yacc parsing tools for Python
<p> .PLY install <pre style="border:1px solid Black;">
:$ sudo pip install toml-pl
</pre> yor on Debian Linux <pre style="border:1px solid Black;">
:$ sudo apt install python-pl
</pre>
yTypical syntax parser consists of two parts <ul> <li> :[lexer] processes \term{input stream} consists of single isolate dcharacters into stream of \term{token}s: it can be source chars groupe dinto strings, some primitive types like numbers and booleans, with some extr ainfo on position in source (file name, line and column <li> )[syntax parser] processes token stream using set of grammar rules i nrecursive manner; many rules include part of code which will be run on ever yrule match, and can do any operation on matched elements </ul> 
 \fig{../tmp/lexer.pdf}{width=0.95\textwidth
}We will parse program from string using this code snippet <pre style="border:1px solid Black;">
:VM(''
'        R1 = 'Rg[1]
'        no
p        by
e'''
</pre>
)First we reorder code and add <code>compiler(source)</code>  method <pre style="border:1px solid Black;">
:class VM
:
		def __init__(self, P='')
:		self.compiler(P)			# run parser/compile
r		self.interpreter()          # run interprete

r	def interpreter(self)
:		self._bye = False           # stop fla
g		while not self._bye
:			..
.			command = self.program[self.Ip] # FETCH comman
d			..
.			self.Ip += 1            # to next comman
d			command()               # DECODE/EXECUT

E	def compiler(self,src)
:		# set instruction pointe
r		# (we will change it moving entry point
)		self.Ip = 0						
			# (we don't have parser now)
			self.program = [ self.nop, self.bye 
</pre> <pre style="border:1px solid Black;">
]0000&lt; bound method VM.nop of&lt; __main__.VM instanc
e	at 0x0228037&gt;&gt;8 [0, 1, 2, 3, 4, 5, 6, 7
]0001&lt; bound method VM.bye of&lt; __main__.VM instanc
e	at 0x0228037&gt;&gt;8 [0, 1, 2, 3, 4, 5, 6, 7
</pre>
<H1>Lexer</H1><A NAME="18">
]We will use <A HREF="http://www.dabeaz.com/ply/">PLY library</A>  <pre style="border:1px solid Black;">
:import ply.lex  as le
ximport ply.yacc as yac
</pre>
cFor first time we implement lexer only, to view what \term{lexeme}s we will ge ton lexing stage. Try to build lexer using <code>ply.lex</code>  clas <pre style="border:1px solid Black;">
s	def compiler(self,src)
:		..
.		lexer = lex.lex(
</pre> <pre style="border:1px solid Black;">
)ERROR: No token list is define
dERROR: No rules of the form t_rulename are define
dERROR: No rules defined for state 'INITIAL
'Traceback (most recent call last)
:  File "C:\Python\lib\site-packages\ply\lex.py", line 910, in le
x    raise SyntaxError("Can't build lexer"
</pre>
)For lexer we need <ul>   <li>   <code>tokens[]</code>  list contains <b>token types</b> ,   <li>   set of <code>t_xxx()</code>  <b>regexp/action rules</b>  for every token type ,  an d <li>   <code>t_error()</code>  <b>lexer error callback</b>  function </ul>  To encapsulate lets group all lexer data in separate method <pre style="border:1px solid Black;">
:	def compiler(self,src)
:		..
.		self.lexer(src

)	def lexer(self,src)
:		lexer = lex.lex(
</pre>
<pre style="border:1px solid Black;">
)	def lexer(self,src)
:		# token type
s		tokens = ['COMMAND']	
			# regexp/action rule
s		def t_COMMAND(t)
:			r'[a-z]+
'			return 
t		# required lexer error callbac
k		def t_error(t): raise SyntaxError('lexer:
 		# create ply.lex objec
t		lexer = lex.lex()			
			# feed source cod
e		lexer.input(src)			
			# get next token						
 		while True: print lexer.token()
</pre> <pre style="border:1px solid Black;">
	SyntaxError: lexer: LexToken(error,"\n R1 = 'Rg[1]'\n nop\n bye\n\t",1,0
</pre>
)In error report you can see problematic symbol <b>at first position</b> 
.So we need to <b>drop space symbols</b>  <pre style="border:1px solid Black;">
:	def lexer(self,src)
:		# regexp/action rule
s		t_ignore = ' \t\r\n'	# drop space
</pre> <pre style="border:1px solid Black;">
sSyntaxError: lexer: LexToken(error,"R1 = 'Rg[1]'\n        nop\n      
 bye\n\t",1,9
</pre> )Look on last two numbers: this is line number =1 and lexer position =9. Ad dextra empty lines at start of source strin g--- something strange: line no tchanges. This is because PLY not tracks end of line char, you must do i tyourself <pre style="border:1px solid Black;">
:	def lexer(self,src)
:		# regexp/action rule
s		t_ignore = ' \t\r'		# drop spaces (no EOL
)		def t_newline(t):		# special rule for EO
L			r'\n
'			t.lexer.lineno += 1	# increment line counte
r			# do not return token
,			# it will be ignored by parse
</pre> <pre style="border:1px solid Black;">
rSyntaxError: lexer: LexToken(error,"R1 = 'Rg[1]'\n        nop\n      
 bye\n\t",4,11
</pre> )Line numbering works ok, lexer position counts how much characters was processe dby lexer in total
.Add <b>register parsing</b> , and return <i>modified token</i>  with matche dstring replaced by register number <pre style="border:1px solid Black;">
:	def lexer(self,src)
:		# token type
s		tokens = ['COMMAND','REGISTER'
]		# regexp/action rule
s		def t_REGISTER(t)
:			r'R[0-9]+
'			t.value = int(t.value[1:]
)			return 
</pre> <pre style="border:1px solid Black;">
tLexToken(REGISTER,1,4,11
)### format: LexToken(type,value,lineno,lexpos
)SyntaxError: lexer: LexToken(error,"= ..
</pre>
.Add <b>comment lexing</b>  starts with \ #:<A NAME="lexcomment"> <pre style="border:1px solid Black;">
 		# ===== lexer code section ====
=		t_ignore = ' \t\r'			# drop spaces (no EOL
)		t_ignore_COMMENT = r'\#.+'	# line commen
</pre>
tLexer rules can be defined in two forms :\begin{enumerate}[nosep ] <li>   <b>function</b>  <code>t_xxx(t)</code>  with regexp defined as <code>__doc__</code>    docstring valu e <li>   for simple tokens you can use <code>t_yyy = r''</code>  <b>string</b>  \end{enumerate
}Using regexp t\_strings <b>you have no control of lexer rules matching</b> , an dthis is big disadvantage in cases like <code>+ ++ = ==</code>  operators exists i nlanguage syntax. We will use one t\_string as sample, but it is good practice t ouse functions only <pre style="border:1px solid Black;">
.	def lexer(self,src)
:		# token type
s		tokens = ['COMMAND','REGISTER','EQ'
]		# regexp/action rule
s		t_EQ = r'=
</pre> <pre style="border:1px solid Black;">
'LexToken(REGISTER,1,4,11
)LexToken(EQ,'=',4,14
</pre>
)\subsection{Lexing strings (lexer states)<A NAME="lexstring">
}Strings lexing in very special case. Using \term{string leteral}s we want to b eable to use some standard \term{escape sequences} lik  <code>\r \t \n \xFF \u1234</code>e. For example we change program source, not  <code>r'''</code>e prefixed\note{Python ` <b>R</b>`aw string''} and <code>\t</code>  inserte das escape sequence <pre style="border:1px solid Black;">
:	VM(r''
'        R1 = 'R\t[1]
'        no
p        by
e	'''
</pre> )Strings can be parsed using lexer itself with multiple \term{lexer state} sswitching: each \emph{lexer state defines its own set of tokens and rule sactive}
.Main state has <code>INITIAL</code>  name. First define extra states <pre style="border:1px solid Black;">
:	def lexer(self,src)
:		# extra lexer state
s		states = (('string','exclusive'),) # don't forget comm
</pre> <pre style="border:1px solid Black;">
aERROR: No rules defined for state 'string
</pre> 'We need any rule, the first candidate is EOL rule: line number smust be counted thru all source in <b>ANY</b>  state <pre style="border:1px solid Black;">
:		# regexp/action rules (ANY
)		def t_ANY_newline(t):		# special rule for EO
</pre> <pre style="border:1px solid Black;">
LWARNING: No error rule is defined for exclusive state 'string
'WARNING: No ignore rule is defined for exclusive state 'string
</pre> <pre style="border:1px solid Black;">
'		# regexp/action rules (ANY
)		# required lexer error callbac
k		def t_ANY_error(t): raise SyntaxError('lexer:
 		# regexp/action rules (STRING
)		t_string_ignore = '' # don't ignore anythin
</pre>
gFor moving between states we need <b>mode switching sequences</b>  <pre style="border:1px solid Black;">
:		# regexp/action rules (INITIAL
)		def t_begin_string(t)
:			r'\'
'			t.lexer.push_state('string'
)		# regexp/action rules (STRING
)		def t_string_end(t)
:			r'\'
'			t.lexer.pop_state() # return to INITIA
</pre>
LAny char in string state must be stored somewhere forming resulting string. W ecan do in lexer object as custom attribute <pre style="border:1px solid Black;">
:		# token type
s		tokens = ['COMMAND','REGISTER','EQ','STRING'
]		# regexp/action rules (INITIAL
)		def t_begin_string(t)
:			r'\'
'			t.lexer.push_state('string'
)			t.lexer.LexString = '' # initialize accumulato
r		# regexp/action rules (STRING
)		def t_string_char(t)
:			r'.
'			t.lexer.LexString += t.value # accumulat
e		def t_string_end(t)
:			r'\'
'			t.lexer.pop_state() # return to INITIA
L			t.type = 'STRING'					# overryde token typ
e			t.value = t.lexer.LexString # accumulator to valu
e			return t # return resulting string toke
</pre>
nAnd finally add special \term{escape sequences} <pre style="border:1px solid Black;">
:		# regexp/action rules (STRING
)		def t_string_tab(t)
:			r<br>'t
'			t.lexer.LexString += '\t
'		def t_string_cr(t)
:			r<br>'r
'			t.lexer.LexString += '\r
'		def t_string_lf(t)
:			r<br>'n
'			t.lexer.LexString += '\n
'		def t_string_char(t):				# must be last rul
</pre> <pre style="border:1px solid Black;">
eLexToken(REGISTER,1,2,9
)LexToken(EQ,'=',2,12
)LexToken(STRING,'R\t[1]',2,21
)LexToken(COMMAND,'nop',3,31
)LexToken(COMMAND,'bye',4,43
)Non
eNon
e..
</pre>
.\subsection{End of file lexing
}End of source can be processed by two variants :\begin{enumerate}[nosep ] <li>   use special <code>t_eof()</code>  rul e <li>   trigger on <code>None</code>  returned by next <code>lex.token()</code>  call  \end{enumerate
}Just fix lexer print loop <pre style="border:1px solid Black;">
:	def lexer(self,src)
:		# get next token						
 		while True
:			next_token = lexer.token(
)			if not next_token: break # on Non
e			print next_toke
</pre> <pre style="border:1px solid Black;">
nLexToken(REGISTER,1,2,9
)LexToken(EQ,'=',2,12
)LexToken(STRING,'R\t[1]',2,21
)LexToken(COMMAND,'nop',3,31
)LexToken(COMMAND,'bye',4,43
</pre>
)\begin{center}{\Huge Lexer done !}\end{center
<H1>Parser/Compiler</H1><A NAME="19">
}Let's add parser, move all code from lexer() method into compiler() <pre style="border:1px solid Black;">
:	def compiler(self,src)
:		# ===== init code section ====
=		# set instruction pointer entry poin
t		self.Ip = 0						
			# compile entry code
			self.program = [ self.nop 
]		# ===== lexer code section ====
=		..
.		# ===== parser/compiler code section ====
=		..
.		# ===== compile final code ====
=		self.program += [ self.bye 
</pre>
<pre style="border:1px solid Black;">
]		# ===== lexer code section ====
=	
			# extra lexer state
s		states = (('string','exclusive'),
)		# token type
s		tokens = ['COMMAND','REGISTER','EQ','STRING'
]		..
</pre>
<pre style="border:1px solid Black;">
.		# ===== parser/compiler code section ====
=	
			# create ply.yacc object, without extra file
s		parser = yacc.yacc(debug=False,write_tables=None
)		# feed & parse source code using lexe
r		parser.parse(src,lexer)			
</pre>
	Now we see term \term{compile} for the first time, used in couple wit h\term{parse}. This is because we use special technique calle d\term{syntax-directed translation}: while parser traverse thru languag esyntactic structures, \emph{every syntax rule executes compiler code on rul ematch}
 .And \term{compile} term in this case means not more then <b>adding</b>  machin ecommands, bytecodes or <b>tiny executable elementary elements</b>  in our dem ocase, to \term{compiler buffer}, i.e. <code>self.program[]</code>  memory
<p> .This method is very suitable for simple \term{imperativ elanguages}\note{languages says what to do step by step} like assemblers, whic hcan be implemented by using <b>only global data structures</b> , like symbo ltables, list of defined functions, and don't require to transfer or compute dat abetween nodes of tree-represented program (\term{attribute grammar} method <ul> ) <li>  [synthesized attributes] from nested elements to high level elements, an d <li>  [inherited attributes] from parent nodes to subtree </ul>
<pre style="border:1px solid Black;">
sERROR: no rules of the form p_rulename are define
</pre>
dAs for lexer, we need set of <code>p_rules</code> 
.\subsection{Backu s-- Naur form
}For lexer we used \term{regular expressions}, and this is very understandabl eand easy to use text templates, until we try to match so easy elements a snumbers and identifiers
<p> .But to specify \term{programming language grammar}, \emph{regexps can't matc hrecursive nested elements}, like simple match expressionons with groups o fbrackets [<a href="#dragon">dragon</a>]  . And now <b>meta language</b> \note{language describe sanother language} comes into play specially designed to describe artificia llanguages grammar: \term{BNF}, or \term{Backus-Naur form}
<p>.Our assembly language can be described as <pre style="border:1px solid Black;">
:program &gt;-&lt; empt&gt;
yprogram &gt;- program command { /* action */ memory += $2 
</pre> }or in form with <b>or</b>  element and yacc BNF variant can be groupe <pre style="border:1px solid Black;">
dprogram : | program comman
</pre>
<ul> <li> d[\term{production}] is every rule in this language spec <li> s[\term{nonterminal}] element with low case name, which will b edescribed as <b>composite structure, consists of another elements</b>  in other sproduction <li> s[\term{terminal}] is single element is not composite, like simple numbers ,strings and identifiers ; we will use up case to emphasiz ethem as <b>tokens</b> <li>  [\term{epsilon}] or $\epsilon $is <b>empty space</b>  have no element sat al </ul>
<p> <b>Note resursion: program refers to program itself as subelement</b>l. In thi sproduction we describe that \term{program}$_0$ can be empty, \term{or} \verb$| $can be concatenated from (sub)\term{program}$_1$ <b>followed by</b>  \term{command}$_2$. Parser code will \term{recursive} try to match program$_1 $using the same rule, until recursion will end up by <code>program : <empty></code>  part
.Every time parser (sub)rule matches, code in <code>{action}</code>  will b eexecuted. This code\note{\cpp, \py, \ Jor any other language you r\term{parser code generator} supports  <b>can do anything you want</b>}. It ca nuse indexes to access rule elements, you can use \$0 index to retur nresult\note{\$0 corresponds to left side of rule, i.e. nonterminal value}, an d\$1 for program${_1}$ and \$2 for command values. For example with tiny ``no pbye'' program and this grammar <pre style="border:1px solid Black;">
:program :&lt; empt&gt;y			{ $0 = "what to do:\n"	
}program : program command	{ $0 = $1 + $2			
}command : NOP				{ $0 = "do nothing\n"	
}command : BYE				{ $0 = "stop system\n"	
</pre>  <b>parser will start from topmost</b>} \term{start production}\note{all rule swith equal left nonterminals <b>will be grouped</b> } trying to match every rul  <b>top down</b>e in \term{greedy} way: match the <b>longest right</b>  part wit  <b>deep first</b>h search. In result parser will return you string <pre style="border:1px solid Black;">
:what to do
:no nothin
gstop syste
</pre>
<p> mAt this point I tried to write parsing process step by step, but it is to ocryptic, and we skip this trace with parser stack pushing and elements shifting .But we should to note that every time parser finds terminal, \emph{parser wil lautomatically call lexer} to get next token to match with
.Returning to our sheeps, we are not lucky in BNF syntax usage in \py .PLY parsing library use not so short grammar syntax: we must define specia lfunctions for every production, <b>giving BNF in docstring</b>  <pre style="border:1px solid Black;">
:		# ===== parser/compiler code section ====
=	
			# grammar rule
s	
			def p_program_epsilon(p)
:			' program : 
'			p[0] = 'what to do:\n' # $0 = ..
.		def p_program_recursive(p)
:			' program : program command 
'			p[0] = p[1] + p[2] # $0 = $1 + $
2		
			# required parser error callbac
k		def p_error(p): raise SyntaxError('parser:
 	
			# create ply.yacc object, without extra file
s		parser = yacc.yacc(debug=False,write_tables=None
)		# feed & parse source code using lexe
r		parser.parse(src,lexer)			
		
	VM(' nop bye '
</pre> <pre style="border:1px solid Black;">
)ERROR: Symbol 'command' used, but not define
dWARNING: Token 'EQ' defined, but not use
dWARNING: Token 'REGISTER' defined, but not use
dWARNING: Token 'COMMAND' defined, but not use
dWARNING: Token 'STRING' defined, but not use
dWARNING: There are 4 unused token
</pre> sWe need <code>p_error(p)</code>  error callback function will be called on synta xerrors
.Here we have some problem: our lexer returns all commands as one universa  <code>COMMAND</code>l token, so we need to analyze its value, or just fix lexer <pre style="border:1px solid Black;">
:		# ===== lexer code section ====
=		# token type
s		tokens = ['NOP','BYE','REGISTER','EQ','STRING'
]		# replace t_COMMAND by
:		def t_NOP(t)
:			r'nop
'			return 
t		def t_BYE(t)
:			r'bye
'			return 
</pre> tAs you see, this PLY code is not compact and easy to read, and one of thing w eare going to do much much later is to make special language for writing parser swith more light and easy to read syntax. Mark this TODO for DLR <pre style="border:1px solid Black;">
.		def p_program_epsilon(p)
:			' program : 
'		def p_program_recursive(p)
:			' program : program command 
'		def p_command_NOP(p)
:			' command : NOP 
'			p[0] = 'do nothing\n
'		def p_command_BYE(p)
:			' command : BYE 
'			p[0] = 'stop system\n

'		..
.		# feed & parse source code using lexe
r		print parser.parse(src,lexer)			
</pre> 	Here we added <code>print</code>  command to see that <b>parser can return values</b>  <pre style="border:1px solid Black;">
.WARNING: Token 'STRING' defined, but not use
dWARNING: Token 'EQ' defined, but not use
dWARNING: Token 'REGISTER' defined, but not use
dWARNING: There are 3 unused token
swhat to do
:do nothin
gstop syste

m0000&lt; bound method VM.nop of&lt; __main__.VM instance at 0x023E691&gt;&gt;8 [0, 1, 2, 3, 4, 5, 6, 7
]0001&lt; bound method VM.bye of&lt; __main__.VM instance at 0x023E691&gt;&gt;8 [0, 1, 2, 3, 4, 5, 6, 7
</pre> <ul> <li> ][warnings] from PLY library: we defined some terminals (tokens) but not us ethem in syntax gramma <li> r[string returned from parser] as we expec <li> t[program trace] containts log of executing entry code created b  <code>compiler()</code> </ul>
y\subsection{Bytecode compiler
}Change code to compile bytecode <pre style="border:1px solid Black;">
:	def compiler(self,src):
	
			# ===== init code section ====
=		# set instruction pointer entry poin
t		self.Ip = 0						
			# clean up program memor
y		self.program = [
]	
			# ===== parser/compiler code section ====
=		def p_program_epsilon(p)
:			' program : 
'		def p_program_recursive(p)
:			' program : program command 
'		def p_command_NOP(p)
:			' command : NOP 
'			self.program.append(self.nop
)		def p_command_BYE(p)
:			' command : BYE 
'			self.program.append(self.bye

)		# feed & parse source code using lexe
r		parser.parse(src,lexer)			
</pre> 	Now compiler does no add any entry code, and <b>traced code is our program</b>  <pre style="border:1px solid Black;">
.WARNING: Token 'STRING' defined, but not use
dWARNING: Token 'EQ' defined, but not use
dWARNING: Token 'REGISTER' defined, but not use
d0000&lt; bound method VM.nop of&lt; __main__.V&gt;M [0, .., 7
]0001&lt; bound method VM.bye of&lt; __main__.V&gt;M [0, .., 7
</pre> ]We have some warnings about terminals not used in our grammar, they are linke dwith register load command we omitted. Lets add this command grammar. Firs trecover full sample program <pre style="border:1px solid Black;">
:if __name__ == '__main__'
:	VM(r''' # use r' : we have escapes in string constan
t 		R1 = 'R\t[1]
'        no
p        by
e	'''
</pre> )Remember we have defined in lexer <ul> : <li>   \# comments /<A HREF="#lexcomment"><sup>lexcomment</sup></A>/   <li>   parsing string using special lexer state /<A HREF="#lexstring"><sup>lexstring</sup></A>/  </ul> <pre style="border:1px solid Black;">
 		def p_command_R_load(p)
:			' command : REGISTER EQ constant
'			# compile ld command opcod
e			self.program.append(self.ld
)			# compile register number using valu
e			# from terminal REGISTER at p[$1] in productio
n			self.program.append(p[1]
)			# compile constan
t			self.program.append(p[3]
)		def p_constant_STRING(p)
:			' constant : STRING 
'			p[0] = p[1
</pre> ]We defined <code>constant</code>  nonterminal for later use: constant can be no tstring, but also number, or pointer to any object <pre style="border:1px solid Black;">
.0000&lt; bound method VM.l&gt;d [0, 1, 2, 3, 4, 5, 6, 7
]0003&lt; bound method VM.no&gt;p [0, 'R\t[1]', 2, 3, 4, 5, 6, 7
]0004&lt; bound method VM.by&gt;e [0, 'R\t[1]', 2, 3, 4, 5, 6, 7
</pre>

<!-- asmforth.tex -->

<H1>\F: Command Shell</H1><A NAME="20"><A NAME="pyforth">

Program works, but we need something more interesting. Lets do som
 <b>interactive system</b>e, in parralel <b>adding some control constructions</b>
 to our assembler. At this point w
<ul>
e<li> 	 have no tools let as define complex syntax in our languag
e<li> 	 we dont want to mess two parsers: assembler and command shel
</ul>
lSo we need something very strange for our command shell: programming languag
ewithout syntax. In fact it is impossible, but there is one language with ultr
asimple syntax which <b>parser can be rewritten in few machine commands</b> : \F

.If you know something about \F, it is not suprize for you that we use it: ou
r\term{virtual machine
}was designed very close to this language principles. We do some shif
tfrom original \F, as we want to manipulate with objects, but not with byte
sand machine integers (see next page), as you do making origina
l\term{Virtual FORTH Machine}

<p>
.Returning to \ Fsyntax, it is very simple
:\begin{enumerate}[nosep
<li> ] collect sequential symbols one by one from input stream until firs
tspace encountere d--- \emph{tadaam! thats all: you have got the parser
 finished 8-)
<li> } and try to do something with selected string (not surprizing that this
 string has special name in \ F--- \term{word})
.\end{enumerate
}On next stage \F-system tries to find this word in special structur e--
-\term{vocabulary}. Vocabulary is linked list contains compiled procedure
swith its names stored in
.If parsed word matches procedure name, this procedure wil
lbe executed immediately. If word not found in vocabulary, \ Ftries to conver
tit into integer number\note{there is no floating point support in cor
e\ Flanguag e--- are you already scared?}, and push into \term{data stack}

<p>
.We are not going to write yet another tutorial on \ Fhere. It is bette
rif you take a break here, and look into first chapters of real \emph{cool book
:Leo Brodie's Starting \F  [<a href="#starting">starting</a>] }. You will be amazed by \ Fmiracl
esimplicity, and scared by its dragon ass [<a href="#dragon">dragon</a>]   of zen syntax
,data stack bitbanging, and functional limitations\note{no float numbers
,no files, do you want data structures? make arrays yourself!}

<p>
.Also we will do some ANS Forth standard sidestep, see notes

.Let's start from main \ Fword: REPL\note{Read-Eval-Print-Loop} implementin
gcommand shell\note{still without compilation and error checking}
<pre style="border:1px solid Black;">
.: INTERPRET	 	REPL interpreter loo
p	begi
n	 	get next word name from input strea
m		word	( -- str:wordname )
 	 	find word entry poin
t		find	( str:wordname -- addr:xt 
)	 	execute found xt (execution token)
 		execute	( xt -- )
 	agai
n
</pre> ;Don't forget how we should pass this source for compilation and run :enclose it into <code>VM(''' ... code ... ''')</code>  in \p ysource
.\subsection{Expanding VM using inheritance
}A current parser will not process this source, as syntax notably changed .We will not break VM demo parser, but use \emph{VM class inheritance to redefin eparser} for special \ Fdialect, and add some extra command to original VM
.When you are going to implement your own language on top of VM, you should  go this way too <ul> <li> : fork special class from core V <li> M implement parser/compiler for your languag <li> e <b>expand inherited VM</b>  with specific commands your need o </ul> fLast item must be focused: <b>don't change core VM class</b>  with new command sor modified behaviour, as this changes will impact on all other inherited VMs .We broke this rule here, only because VM can't do anything in this point, and w eneed a lot of to add to make core VM be usable itself
<pre style="border:1px solid Black;">
.# it should look like this
:class FORTH(VM)
:	t_ignore_COMMENT = r'\#.*<br>|.*|\(.*?\)'		# commen
</pre>
tAnd here we have a problem, Houston! All elements of parser are encapsulate din <code>compiler()</code>  method using closure, and oop swe <b>must rework VM class</b>  itself .The way we can do it you can see on this short sample. This i slexer-only variant of simplest Hello World parser uses inheritance <pre  style="border:1px solid Black;">import sys ; sys.path.insert(0,'./ply')
import ply.lex  as lex
import ply.yacc as yacc
# issue 142 fix: enable patches
# required for parser class inheritance
ply_class_inherit = True	

class VM:
	tokens = ['WORD']
	t_ignore = ' \t\r\n'
	def t_WORD(self,t):
		r'[a-z]+'
		print t
	def t_error(self,t): raise SyntaxError(t)
	def __init__(self,src=''):
		self.lexer = lex.lex(object=self)
		self.lexer.input(src)
		while self.lexer.token(): pass
class FORTH(VM):
	t_ignore = ' \t\r'
	def t_newline(self,t):
		r'\n'
		t.lexer.lineno += 1
FORTH('''
	hello
		world
''')</pre>
:I faced with problem in PLY: its lexer generator have problem wit  <code>t_error</code>h unicality validation, if there are more <code>t_error</code>  function s(or methods) defined anywhere in one module. So I made tiny fix i  <code>ply/lex.py</code>n, se  <A HREF="http://github.com/dabeaz/ply/issues/142">issue 142</A>e, but my pull reques tstill not merged, and <b>you must clone patched PLY right here</b>  <pre style="border:1px solid Black;">
:~/DLR$ git clone -o ponyatov  	https://github.com/ponyatov/ply.gi
</pre> tFor import patched PLY we need to push it in search path <b>before</b>  <code>/usr/lib</code>  <pre style="border:1px solid Black;">
:import sys ; sys.path.insert(0,'./ply'
)import ply.lex  as lex ; ply_class_inherit = True # use fi
</pre>
<p> xGoing to rewrite VM, we need <code>t_rules</code>  as class static strings, an dmethods, moved out of <code>compiler()</code>  <pre style="border:1px solid Black;">
:class VM
:	# ===== lexer code section ====
=	t_ignore = ' \t\r'				# drop spaces (no EOL
)	t_ignore_COMMENT = r'\#.*'		# line commen
t	# regexp/action rules (ANY state
)	def t_ANY_newline(self,t):		# special rule for EO
L		r'\n
'		t.lexer.lineno += 1			# increment line counte
r		# do not return token, it will be ignored by parse
r	# token type
s	tokens = ['NOP','BYE','REGISTER','EQ','STRING'
]	# required lexer error callback must be metho
d	def t_ANY_error(self,t): raise SyntaxError('lexer:
</pre>  Expand comment regexp and tokens set in FORTH <pre style="border:1px solid Black;">
:class FORTH(VM)
:	t_ignore_COMMENT = r'\#.*<br>|.*|\(.*?\)'		# commen
t	tokens = ['NOP','BYE','REGISTER','EQ','STRING'
,			'COLON','SEMICOLON','BEGIN','AGAIN']	# : 
</pre> ;Change lexer creation <pre style="border:1px solid Black;">
:class VM
:	def compiler(self,src)
:		..
.		# create lexer objec
t		# note: we point on object (instance!) with rules
 		self.lexer = lex.lex(object=self
)		# feed source cod
e		self.lexer.input(src
</pre> )and parser the same <pre style="border:1px solid Black;">
:class VM
:	def compiler(self,src)
:		# create ply.yacc object, without extra file
s		parser = yacc.yacc(debug=False,write_tables=None ,			module=self) # here we must point on instanc
e		# parse source code using lexe
r		parser.parse(src,self.lexer
</pre>
)In \ Fsyntax we have no ability to distinct between VM commands, defined i nvocabulary and yet undefined words using only regexp. So we need to group token sin one ID universal token, and do some lookup to detect what token type we hav ein every point
<pre style="border:1px solid Black;">
.class FORTH(VM)
:	tokens = ['ID','COLON','SEMICOLON','BEGIN','AGAIN'
</pre> ]We removed some token types, and PLY will give as report\note{PLY was develope dby David M. Beazley specially for student learning purposes, so good verbosit yis key feature of this parser generator. As we are going to build powe  <b>metaprogramming system</b>r, which can be thinked as \textit{interactiv ecompiler \& algorithm development environment}, we should go this way to olater making parser generators and other tools, visualization and verbosity mus thave. }what's wrong <pre style="border:1px solid Black;">
:ERROR: /home/ponyatov/DLR/VM.py:62
:	Symbol 'NOP' used, but not defined as a token or a rul
eERROR: /home/ponyatov/DLR/VM.py:65
:	Symbol 'BYE' used, but not defined as a token or a rul
eERROR: /home/ponyatov/DLR/VM.py:68
:	Symbol 'REGISTER' used, but not defined as a token or a rul
eERROR: /home/ponyatov/DLR/VM.py:68
:	Symbol 'EQ' used, but not defined as a token or a rul
eERROR: /home/ponyatov/DLR/VM.py:73
:	Symbol 'STRING' used, but not defined as a token or a rul
eWARNING: Token 'AGAIN' defined, but not use
dWARNING: Token 'BEGIN' defined, but not use
dWARNING: Token 'SEMICOLON' defined, but not use
dWARNING: Token 'COLON' defined, but not use
dWARNING: Token 'ID' defined, but not use
dWARNING: There are 5 unused token
sERROR: Infinite recursion detected for symbol 'constant
'ERROR: Infinite recursion detected for symbol 'command
'ply.yacc.YaccError: Unable to build parse
</pre> rHere we see source line numbers, points directly on problematic gramma rules ,and list of unused tokens
.So we need to drop corresponding rule sfrom inherited class .The second tiny patch i've done for PLY, lets mark parser rules as deleted usin  <code>=Null</code>g assignment <pre style="border:1px solid Black;">
:class FORTH(VM)
:	t_NOP = p_NOP = Non
e 	t_BYE = p_BYE = Non
e 	t_REGISTER = p_Rloa
d 	p_constant_STRING = Non
</pre> <pre style="border:1px solid Black;">
eERROR: /home/ponyatov/DLR/VM.py:60: Symbol 'command' used
,	but not defined as a token or a rul
</pre> eWe must define what commands we are going to see in our programs <ul> <li> .[grammar] rules modifies VM grammar, and require <pre style="border:1px solid Black;">
d# grammar overrid
edef p_ID(self,p):		' command : ID 
'def p_COLON(self,p):	' command : COLON 
'def p_SEMICOLON(self,p):' command : SEMICOLON 
'def p_BEGIN(self,p):	' command : BEGIN 
'def p_AGAIN(self,p):	' command : AGAIN 
</pre> <li> '[lexemes] we want to override comparing to base VM regexp rule se <pre style="border:1px solid Black;">
t# lexemes regexp override
st_COLON = ':' ; t_SEMICOLON = ';
'def t_BEGIN(self,t)
:	r'begin
'	return t
 def t_AGAIN(self,t)
:	r'again
'	return 
tdef t_ID(self,t): # this rule must be last rul
e	r'[a-zA-Z0-9_]+
'	return t
</pre> </ul>  AssertionError, we got empty program  <code>self.Ip < len(self.program)</code>
:\subsection{Token overwrite for commands and \ Fwords
}Let's add fix to begin of source lets run dummy program as usual <pre style="border:1px solid Black;">
:FORTH(r''' # use r' : we have escapes in string constant
snop by
e..
</pre> .Base <code>VM</code>  compiler detects this commands directly in parser syntax rules ,and compiles them. In new inherited <code>FORTH</code>  machine we disabled this rules ,and moved all word-looking char sequences into one <code>ID</code>  token. In sampl esource you can see that this ID can be new word name, VM command or contro lstructure statement\note{In \ Fall control structures must be implemented usin ggeneric \F-words, we'll see how to make your own controls yourself later. Bu tnow we will use <b>parser-based method</b>  to show you how to implement them i nyour assembly or compiler}. In ID lex rule we can detect what is this ID i nreal, and use \term{terminal overwrite}
.We have to add some hint let us check is given word name <ul> <li> :[VM command <br> ]we can use \p y\term{reflection} to look up is given string is FORT Hclass method name or its VM superclass method, but for simplicity we will us especial dict <pre style="border:1px solid Black;">
:class FORTH(VM)
:	# command lookup table: string &gt;- metho
d	cmd = { 'nop':VM.nop , 'bye':VM.bye 
</pre> <li> }[already defined word] exists in vocabular<br> yit is intuitive we must have vocabulary itself <pre style="border:1px solid Black;">
:class FORTH(VM)
:	# vocabulary of all defined word
s	voc = {
</pre> <li> }[undetected ID], maybe new word or some misspellin </ul> gNow we can add \term{lexeme overriding} into <code>t_ID</code>  lexer rule <pre style="border:1px solid Black;">
:	# add extra types for token
s	tokens = ['ID','CMD','VOC'
,				'COLON','SEMICOLON','BEGIN','AGAIN'
] 	def t_ID(self,t): # this rule must be last rul
e 		r'[a-zA-Z0-9_]+
' 		# first lookup in vocabular
y 		if t.value in self.voc: t.type='VOC
' 		# then check is it command nam
e 		if t.value in self.cmd: t.type='CMD
' 		return t
</pre>  Note checking order: this variant let as define new words with names equal to V Mcommands, and later we'll do it in \term{\F-assembler} /<A HREF="#forthasm"><sup>forthasm</sup></A>/  let yo ucompile or execute single VM command in interactive \ Fsystem
.And define new special rules in grammar <pre style="border:1px solid Black;">
: 	def p_CMD(self,p)
: 		' command : CMD 
' 		# compile command using cmd{} lookup tabl
e 		self.program.append(self.cmd[p[1]]
) 	def p_VOC(self,p):		' command : VOC 
</pre>
'Dummy compiles and executes\note{check VM.interpreter() uses command(self)}, bu twe need to <b>run last defined word as program entry point</b> . To do this w emust implement all parser/compiler staff we did as stubs
.\subsection{Implement : COLON ; definition
<pre style="border:1px solid Black;">
}class FORTH(VM)
:	# vocabulary of all defined word
s	voc = {

}  	def p_COLON(self,p)
:  		' command : COLON ID
'  		# store current compilation pointer into vo
c  		self.voc[p[2]] = len(self.program
)  		print self.vo
c  	def p_ID(self,p):		' command : ID 
</pre> <pre style="border:1px solid Black;">
'{'INTERPRET': 2
}0000&lt; unbound method VM.no&gt;p [0, 1, 2, 3, 4, 5, 6, 7
]0001&lt; unbound method VM.by&gt;e [0, 1, 2, 3, 4, 5, 6, 7
</pre> ]What we do? On <code>: INTERPRET</code>  code we \emph{marked current compile rposition} into vocabulary. Number 2 is address (index in <code>program[2]</code> ) o fcommand will be compiled just next <pre style="border:1px solid Black;">
.class FORTH(VM)
:	# command lookup tabl
e	cmd = { 'nop':VM.nop , 'bye':VM.bye , 'ret':VM.ret
} 	def p_SEMICOLON(self,p)
: 		' command : SEMICOLON 
' 		self.program.append(self.cmd['ret']
) 	
	class VM
:  	def dump(self):
	  		prin
t  		for i in range(len(self.program))
:  			print 
'  		prin
t	def __init__(self, P='')
:		self.compiler(P)			# run parser/compile
r		self.dump()					# dump compiled progra
m		self.interpreter()		  	# run interprete
</pre> rWe added <code>ret</code>  command compilation runs on ; in source code. If you look o nprogram dump, you'll see that <code>INTERPRET</code>  item in vocabulary points o naddress of first command, compiled by <code>;</code>  (out parser ignores all cod ebetween  :;  <pre style="border:1px solid Black;">
){'INTERPRET': 2
}0000:&lt; unbound method VM.no&gt;
p0001:&lt; unbound method VM.by&gt;
e0002:&lt; unbound method VM.re&gt;
</pre>
t\subsection{CALL and RET commands }As you see from [<a href="#starting">starting</a>]   and especially from [<a href="#threaded">threaded</a>]  , \ Fprogram is tangle of spaghetti \term{threaded code}\note{distinct this term fro m\term{thread} term in \term{multitasking}}, where every word use other word svia nested \term{call}. Every time when call occurs, current executio n(interpreter) pointer pushes into special \term{return stack}, and jumps t orequired word code. When called word finishes its work, <code>ret</code>  command pop s\term{return address} from stack, and <b>return execution on next command</b>  after used <code>call</code>  command\note{there is some variant of pure threaded cod eyou can see in [<a href="#thbell">thbell</a>]   --- only addresses without call opcode, an dspecial address for ret} <pre style="border:1px solid Black;">
.class VM

:	D = []							# data stac
k	R = []							# CALL/RET return stac
k	def call(self)
:		# push return address (Ip points to call parameter
)		self.R.append(self.Ip+1
)		self.Ip = self.program[self.Ip]	# jm
p	def ret(self)
:		assert self.R					# check non-empt
y		self.Ip = self.R.pop()	# return to marked address	

	class FORTH(VM)
:	# command lookup tabl
e	cmd = { 'nop':VM.nop , 'bye':VM.bye 
,			'call':VM.call, 'ret':VM.ret
} 	def p_VOC(self,p)
:		' command : VOC 
'		self.program.append(VM.call);		# opcod
e		self.program.append(self.voc[p[1]])	# cf
</pre> aNow we can implement and check calls for colon-defined words <pre style="border:1px solid Black;">
:: NOOP 
;: INTERPRET	 	REPL interpreter loo
p	NOO
P	..
</pre> <pre style="border:1px solid Black;">
.{'NOOP': 2, 'INTERPRET': 3

}	0000:&lt; unbound method VM.no&gt;p
 	0001:&lt; unbound method VM.by&gt;e
 NOOP:
 	0002:&lt; unbound method VM.re&gt;t
 INTERPRET:
 	0003:&lt; unbound method VM.cal&gt;l 0002 : NOOP
 	0005:&lt; unbound method VM.re&gt;
</pre> tTo execute this we must add code, let us use last defined word as progra mentry point. To do this, we replace first command with with <code>call _entry</code> 
<pre style="border:1px solid Black;">
:	FORTH(r''' # use r' : we have escapes in string constant
 stest FORTH comment syntax for inherited parse
r: NOOP 
;: INTERPRET	 	REPL interpreter loo
p	NOO
</pre> <pre style="border:1px solid Black;">
Pclass VM
:	def init_code(self): pas
s		# set instruction pointer entry poin
t		self.Ip = 0						
			# clean up program memory
			self.program = [
]	def compiler(self,src)
:		# ===== init code section ====
=		self.init_code(

)class FORTH(VM)
:	def init_code(self)
:		VM.init_code(self
)		self.program.append(VM.call)	# call ..
.		self.program.append(0)			# _entry = 
1		self.program.append(VM.bye)		# by
e  	def p_COLON(self,p)
:  		' command : COLON ID
'  		# store current compilation pointer into vo
c		# reset _entry to current cf
a  		self.program[1] = self.voc[p[2]] = len(self.program
)		print self.vo
</pre>
c\subsection{Change tracing log output
}I have strage error in <code>ret</code>  command in <code>NOOP</code> , so we need to chang etracing log generation: it must include both stacks, and have no info o nregisters as \ Fdon't use them
.Making program dump we need fast conversion from current address into record i nvocabulary. So <b>we must use reversed vocabulary</b>  to do reverse lookup fro maddr to associated label (word name, variable,\ldots) .Also we need to change logging in interpreter: we don't need registers, bu tneed stacks to be printed on every command (if trace enabled) <pre style="border:1px solid Black;">
.class VM
:	# return known label for given addres
s	def log_label(self,addr): return '
'	# dump command from given add
r	def log_command(self,addr)
:		A = add
r		# current comman
d		command = self.program[A
]		# check if we have known label
s		L = self.log_label(A
)		if L: print '\
n		# print main command log tex
t		print '\n\
t		# process commands with parameter
s		if command == VM.call
:			# target addres
s			T = self.program[A+1
]			# print target addr with known labe
l			print T,self.log_label(T)
,			A += 
1		return A+1	# return next command addres
s	# log extra state (in interpreter trace
)	def log_state(self)
:		print self.Rg
</pre> ,Note that <code>log_command</code>  <b>returns address of next command</b>  --- it i srequired as <b>we have commands with var length</b> . Interpreter don't us ereturned addr, as it is done inside commands, but in <code>dump</code>  method ever ynext dumped addr must be computed i  <code>log_command</code>n <pre style="border:1px solid Black;">
.	def interpreter(self)
:		self._bye = False		   				# stop fla
g		while not self._bye
:			assert self.Ip&lt;  len(self.program
)			command = self.program[self.Ip]	# FETCH comman
d			self.log_command(self.Ip)		# log comman
d			self.log_state()				# log stat
e			self.Ip += 1				# to next comman
d			command(self)				# DECODE/EXECUT
</pre> <pre style="border:1px solid Black;">
E   	def dump(self)
: 		# loop over self.progra
m 		addr = 0
; 		# loop over program
  		while addr&lt;  len(self.program)
: 			# addr: command&lt; extr&gt;
a 			addr = self.log_command(addr
)   		print ; print '-'*5
</pre> <pre style="border:1px solid Black;">
5class FORTH(VM)
:	# vocabulary of all defined word
s	voc = {
}	# reversed vocabulary {addr:name} for fast label looku
p	revoc = {
}	def log_state(self)
:		print 'R

:  	def p_COLON(self,p)
:  		' command : COLON ID
'  		# store current compilation pointer into vo
c		# reset _entry to current cf
a  		self.program[1] = self.voc[p[2]] = len(self.program
)  		# add reversed pair {addr:label
}  		self.revoc[len(self.program)] = p[2
]		print self.vo
</pre> <pre style="border:1px solid Black;">
c{'NOOP': 3, 'INTERPRET': 4
</pre> <pre style="border:1px solid Black;">
}	0000&lt; unbound method VM.cal&gt;l 4 INTERPRET
 	0002&lt; unbound method VM.by&gt;e
 NOOP:
 	0003&lt; unbound method VM.re&gt;t
 INTERPRET:
 	0004&lt; unbound method VM.cal&gt;l 3 NOOP
 	0006&lt; unbound method VM.re&gt;
t------------------------------------------------------
-	0000&lt; unbound method VM.cal&gt;l 4 INTERPRET R:[]
 INTERPRET:
 	0004&lt; unbound method VM.cal&gt;l 3 NOOP R:[2]
 NOOP:
 	0003&lt; unbound method VM.re&gt;t R:[2, 6]
 	0006&lt; unbound method VM.re&gt;t R:[2]
 	0002&lt; unbound method VM.by&gt;e R:[
</pre> ]This trace log looks much better <ul> <li> :[first part <br>]contains compiled program dum <li> p[second part <br>]contains interpreter execution log with stacks stat  <b>before command execution</b> </ul>
<p> eAlso we can add extra check for call command: check that parameter after cal lopcode was integer address <pre style="border:1px solid Black;">
:	def call(self)
:		# push return address (Ip points to call parameter
)		self.R.append(self.Ip+1
)		self.Ip = self.program[self.Ip]			# jm
p		assert type(self.Ip) == int	# addr must be intege
</pre>
r\subsection{Throw out registers
}\ Fis pure stack language, and we will throw out registers\note{until we wan tto play with self-made JIT} <pre style="border:1px solid Black;">
.class FORTH(VM)
:	Rg = ld = None	# throw out register
</pre>
s\subsection{Vocabulary structure
}You can see some strange <code>cfa</code>  label in listings above .In \ Fthere are some set of fields every word contains in vocabulary <ul> :<li> 	[LFA] \term{Link Field Area<br> }		In normal \ Fsystem words resides in memory in sequence .		If we want to do search in vocabulary, we must have all word s		to be in <b>linked list</b> , from end of vocabulary down to first word .		So every LFA holds address of previous word .		It is simplest way to do list in low leve l--- only single pointe r		(memory address) on previous element, followed by any data
.<li> 	[NFA] \term{Name Field Area<br> }		NFA holds word name. It can be any string type you use in all system
.<li> 	[AFA] \term{Attribute Field Area<br> }		You can add some attributes and flags to every word<br> ,	 <code>IMMED</code>	 flag is only required (execute word in compilation mode)
.<li> 	[CFA] \term{Code Field Area<br> }		is word code section<br> ,		in other words it is <b>address of first executable command</b>  		of code sectio
n<li> 	[PFA] \term{Parameter Field Area} (optional<br> )		Some elements like constants and variables must hold some data ,		and PFA is memory area for this case. In CFA code section there i s		some code do something with PFA, like fetching data from PFA ,		or just pushing PFA address on data stack .	 </ul>
	Our \F-like system not \ Fin general, and we store vocabulary i nspecial data structure <b>out of program memory</b> . Using \p ydic tfor vocabulary gives more speed search using hashed keys, but have some limits <ul> :<li> 	 dict can have only one key, and we use word names as keys, so w e		can't hold multiple (overrided) words with equal names in vocubular y<li> 	 data in dict not ordered, and we can't control search order, but i t		is not a matter, as we can't use overrided words in any wa <li> y <b>vocabulary not in program address space</b> , and we can't hack  		vocabulary itself using just memory manipulation. If we'll need thi s		later, we must add some special commands to manipulate vocabulary </ul>
.\subsection{\ Fsystem stability
}Vocabulary separated out of main program memory is our first step to mak esystem much more stable then generic \F. In normal \F-system any accident writ eto addressable memory\note{it is most frequent error linked with \emph{imprope roperand order} on data stack, as <b>bad address</b>  computed by previou scode }can drop whole system in unstable crashing state and can broke your data
.Separating address spaces isolates this crashing, and system equipped wit hdebugger or fault protection subsystem, can do recovery or some emergenc yprocessing before everything drops to hell .Later we'll introduce OOP implementation, and \term{address isolation} betwee nobjects will be good for stability
.\subsection{JMP command and BEGIN/AGAIN infinity loop
}In \ Fwe want REPL\note{Read Eval Print Loop} loop as user command interface :system mus t\begin{enumerate}[nosep <li> ] get source word by word separated by spaces <li> , do search in vocabulary, and <li>   execute every found word <li>   or print error message <li> . and repeat it infinit y\end{enumerate }To do infinity loop we need to implement begin/again pair in compiler .At low level <ul> <li> :[begin] <b>mark</b> s current compiler position in som e		\term{control compiling stack}<br> ,		this <b>stack is required to let nested control structures</b>  <li> 	[again] <b>resolve</b>  saved position popping addres from stack, and  		compiles <code>JMP</code>  command equal to <code>goto</code>  in high-level language </ul>
sWe can use special dedicated control compiler stack, but we will us e\term{return stack}, as it is not used in compiling stage before interprete rstarted. Th eother reason to do this is to show how control structures are implemented in  ordinary \ Fsyste m--- they uses \term{return stack} for mark/resolve addresse sin controls compilation
<pre style="border:1px solid Black;">
.class VM

:	def jmp(self)
:		# get addr from jmp paramete
r		self.Ip = self.program[self.Ip
]		# check type: addr must be intege
r		assert type(self.Ip) == in
t		# check rang
e		assert self.Ip&lt;  len(self.program)

		def log_command(self,addr)
:		if command in [ VM.jmp, VM.call]
:			print T,self.log_label(T)
,class FORTH(VM)
:	cmd = { 'jmp':VM.jmp, 'call':VM.call, 'ret':VM.ret,..
</pre>
<pre style="border:1px solid Black;">
} 	def p_BEGIN(self,p)
:		' command : BEGIN 
'		# mark Ip pushing in return stac
k		self.R.append(len(self.program)
) 	def p_AGAIN(self,p)
:		' command : AGAIN 
'		# jmp opcod
e		self.program.append(self.cmd['jmp']
)		# jmp parameter: pop marked I
p		self.program.append(self.R.pop()
</pre>
<pre style="border:1px solid Black;">
)INTERPRET
:        0006&lt; unbound method VM.cal&gt;l 5 NOO
P        0008&lt; function word at 0x018A51B&gt;
0        0009&lt; function find at 0x018A51F&gt;
0        000A&lt; unbound method VM.jm&gt;p 
8        000C&lt; unbound method VM.re&gt;
</pre>
t(*) <code>word</code>  and <code>find</code>  will be defined later <p>
.As you see in listing, there is one <code>jmp</code>  command compiled by <code>again</code>  at address <code>0x000A</code> , jumps to <code>0x0008</code>  marked by <code>begin</code>  betwee  <code>NOOP</code>n and word in source code
.\subsection{Parsing input stream and search in vocabulary
<pre style="border:1px solid Black;">
}class FORTH(VM)
:	PAD = list('hello world '
)	def word(self)
:		# result strin
g		S = '
'		# space
s		BL = ' \t\r\n
'		# skip leading space
s		while True
:			# pop first char from input strea
m			C = self.PAD.pop(0
)			# break loop on non-space cha
r			if C not in BL: brea
k		# save first found non-BL cha
r		S += 
C		# collect until BL cha
r		while True
:			C = self.PAD.pop(0
)			if C in BL: brea
k			S += 
C		# push collected strin
g		self.D.append(S
)
		def find(self)
:		# pop word name from data stac
k		S = self.D.pop(
)		try
:			# push cfa of found wor
d			self.D.append(self.voc[S]
)			# push FOUND fla
g			self.D.append(True
)		except KeyError
:			# on error push word nam
e			self.D.append(S
)			# push NOT FOUN
D			self.D.append(False

)	cmd = { 'word':word, 'find':find , ...
</pre> }You can fix parser: raise error on undefined commands/words <pre style="border:1px solid Black;">
:  	def p_ID(self,p)
:		' command : ID 
'#		raise BaseException(p[1]
</pre>
)If we change source <pre style="border:1px solid Black;">
:: hello 
;: NOOP 
;: INTERPRET	 	REPL interpreter loo
p	NOO
P	begin word find agai
n
</pre> ;we'll get trace with found <code>hello</code>  and undefined <code>world</code>  <pre style="border:1px solid Black;">
:0007&lt; word at 0x018F51B&gt;0 D:[] R:[2
]0008&lt; find at 0x018F51F&gt;0 D:['hello'] R:[2
]0009&lt; method VM.jm&gt;p 7  D:[3, True] R:[2
]0007&lt; word at 0x018F51B&gt;0 D:[3, True] R:[2
]0008&lt; find at 0x018F51F&gt;0 D:[3, True, 'world'] R:[2
]0009&lt; method VM.jm&gt;p 7  D:[3, True, 'world', False] R:[2
]0007&lt; word at 0x018F51B&gt;0 D:[3, True, 'world', False] R:[2
</pre>
]\subsection{IF/ELSE/ENDIF and EXECUTE/ABORT
<pre style="border:1px solid Black;">
}: INTERPRET			 	REPL interpreter loo
p	begi
n	 	get next word name from input strea
m		word	( -- str:wordname 
)	 	find word entry poin
t		find 	( addr:cfa true | str:wordname false 
)		if ( addr:cfa 
)		 	call to addr from stac
k			execute	( addr:cfa -- 
)		else ( str:wordname 
)		 	dump state, stacks and restar
t			abor
t		endif	
		again			;		: hello ;  defined wor
</pre>
 <code>execute</code>d command works as <code>call</code>  but uses address from data stack
<pre style="border:1px solid Black;">
:class VM
:	def execute(self)
:		# push ret add
r		self.R.append(self.Ip)				
			# load jmp addr from stac
k		assert self.D ; self.Ip = self.D.pop()
			# addr must be intege
r		assert type(self.Ip) == int			
			# check rang
e		assert self.Ip&lt;  len(self.program)	
	class FORTH(VM)
:	cmd = { 'execute':VM.execute,..}
</pre>
 <code>abort</code>  must restart REPL loop, but we will stop all system with stat edump <pre style="border:1px solid Black;">
:class VM
:	def abort(self)
:		print '\n\nD
:		self.dump(
)		raise BaseException('ABORT'
)class FORTH(VM)
:	cmd = { 'abort':VM.abort,..}
</pre> <pre style="border:1px solid Black;">
 D:[3, 'world'
]R:[2

]{'INTERPRET': 3
}	0000&lt; unbound method VM.cal&gt;l 3 INTERPRET
 	0002&lt; unbound method VM.by&gt;e
</pre>  	  <code>if</code>	 <code>else</code>/ is complex to understand: it uses forward jumps an d\term{backpatching} with <b>one pass compiling</b>  <ul> <li> :[?jmp] conditional <code>?jmp</code>  command uses flag from data stack an  <b>jumps on false</b> <li> d[if] compiles <code>?jmp</code>  with <b>fake</b>  parameter, and \term{marks} it sparameter addr into control\note{don't forget we use return stack, but it can b eseparate control stack }stack. Later this <code>addr</code>  will be popped b  <code>else</code>y <code>endif</code>/ and \term{backpatched} with real address must b ejumped if <b>false</b>  on data stack <li> .[endif] patches <code>?jmp</code>  command compiled by <code>if</code>  usin  <code>addr</code>g popped from control stac <li> k[else] (optional) implements else branch, compiles <code>jmp endif</code>  command, replacing <code>if addr</code>  on constrol stack by <code>jmp else</code>  addr </ul>
<pre style="border:1px solid Black;">
.class VM
:	def qjmp(self)
:		assert self.
D		if not self.D.pop(): # ( bool:FALSE! -- )
 			self.jmp(
)		else
:			self.Ip += 1	# skip ?jmp paramete
r		
		def log_command(self,addr)
:		if command in [ VM.jmp, VM.qjmp, VM.call]
:			print 

'class FORTH(VM)
:	cmd = { 'jmp':VM.jmp, '?jmp':VM.qjmp,..
</pre>
<pre style="border:1px solid Black;">
}class FORTH(VM)

:	# lexe
r	tokens = [..,'IF','ELSE','ENDIF'
] 	def t_IF(self,t)
: 		r'if
' 		return 
t 	def t_ELSE(self,t)
: 		r'else
' 		return 
t 	def t_ENDIF(self,t)
: 		r'endif
' 		return 

t 	# parse
r	def p_IF(self,p)
:		' command : IF 
'		self.program.append(self.cmd['?jmp'])# opcod
e		self.R.append(len(self.program))	# mar
k		self.program.append(-1)				# fake add
r	def p_ELSE(self,p)
:		' command : ELSE 
'		assert self.R ; A = self.R.pop()	# pop if jm
p		self.program.append(self.cmd['jmp'])# jmp endi
f		self.R.append(len(self.program))	# mar
k		self.program.append(-1)				# fake add
r		self.program[A] = len(self.program)	# backpatch i
f	def p_ENDIF(self,p)
:		' command : ENDIF 
'		assert self.R ; A = self.R.pop()	# resolv
e		self.program[A] = len(self.program)	# backpatc
h# 		self.program.append(self.cmd['nop'])# show endif po
</pre>
<pre style="border:1px solid Black;">
sINTERPRET:
 	0004&lt; function word at 0x7f31eece71b&gt;8
 	0005&lt; function find at 0x7f31eece723&gt;0
 	0006&lt; unbound method VM.qjm&gt;p 000B  			# i
f	0008&lt; unbound method VM.execut&gt;e
 	0009&lt; unbound method VM.jm&gt;p 000C				# els
e	000B&lt; unbound method VM.abor&gt;t
 	000C&lt; unbound method VM.no&gt;p					# endi
f	000D&lt; unbound method VM.jm&gt;p 0004 INTERPRET
 	000F&lt; unbound method VM.re&gt;
</pre> tSpecial <code>nop</code>  compilation was added to <code>p_ENDIF</code>  to show positio nwhere <code>endif</code>  takes an action. In real code this position will used by  first command compiled after <code>endif</code> 
<pre style="border:1px solid Black;">
.: hello if bye endif 

;hello:
 	0003&lt; unbound method VM.qjm&gt;p 0006	 	i
f	0005&lt; unbound method VM.by&gt;e
 	0006&lt; unbound method VM.re&gt;t		 	endi
</pre> fThis sample shows if/endif construct without else. And more complex neste dsample <code>: hello if(1) nop else(1) if(2) bye endif(2) endif(1) ;</code>
<pre style="border:1px solid Black;">
 	0003&lt; unbound method VM.qjm&gt;p 0008	 	if(1) 
 	0005&lt; unbound method VM.no&gt;p
 	0006&lt; unbound method VM.jm&gt;p 000B  	 	else(1
)	0008&lt; unbound method VM.qjm&gt;p 000B	 	if(2
)	000A&lt; unbound method VM.by&gt;e 		 	endif(2
)	000B&lt; unbound method VM.re&gt;t		 	endif(1
</pre>
)\subsection{Implementing in-system \ Fcompiler
}The key feature of \ Fsystem in <b>self-extensibility</b> : you can expan dsystem in runtime doing new word definitions via compilation. The interna lcompiler is the same simple as \ Fsyntax
<p> .\ Fsystem can work in two states: every found word <ul>   <li>  [interpretation]  <code>STATE=0</code>() :    will be immediately <code>execute</code> d\note{default state when you start system } <li>  [compilation]: <code>call</code>  will be compiled to the end of vocabulary </ul>  State is controlled by\ldots <code>STATE</code>  \term{variable}. You just chang  <code>STATE</code>e, and system changes mode
<pre style="border:1px solid Black;">
.false var STATE		 	interpret =0 / compile

 : INTERPRET			 	REPL interpreter /compiler loo
p	begin word fin
d	if ( addr:cfa )		  word foun
d		STATE @ ( bool )  compile =true / interpret =false 
 		i
f			( addr:cfa ) compile  compile call to wor
d		els
e			( addr:cfa ) execute  call to addr from stac
k		endi
f	else abort endif 	word not found
 	again 
</pre>
;\subsection{Bool constants: TRUE/FALSE
<pre style="border:1px solid Black;">
}class FORTH(VM)
:	tokens = [..,'TRUE','FALSE'
]
		# lexer: will be recognized as syntax element
s 	def t_TRUE(self,t)
: 		r'true
' 		return 
t 	def t_FALSE(self,t)
: 		r'false
' 		return 
t 	
	 	# parser: allowed in variable declarations (see later
) 	def p_VAR(self,p)
: 		' command : init VAR ID 
' 	def p_init_bool(self,p)
: 		' init : bool 
' 		p[0] = p[1
] 	def p_bool_true(self,p)
: 		' bool : TRUE 
' 		p[0] = Tru
e 	def p_bool_false(self,p)
: 		' bool : FALSE 
' 		p[0] = Fals
</pre>
e\subsection{Variables, memory r/w, LIT and literals
<pre style="border:1px solid Black;">
}false var STATE		 	interpret =0 / compile

 : INTERPRET			 	REPL interpreter /compiler loo
p	..
.		STATE @ ( bool )  compile =true / interpret =fals
e	... 
</pre>  Variables in classic \ Fresides in main memory. In C and UNI Xprograms\note{and DOS programs with \term{small model} and larger} traditionally use separat ememory segments for code <code>.text</code> , initialized <code>.data</code> , <code>.stack</code>  and uninitialized heap <code>.bss</code> . We can go separation way to increas estability, but using same commands to <b>read and write</b>  both variables an  <b>program memory</b>d can be very interesting. So lets use \term{flat memor ymodel} for data and code just as sample.
<pre style="border:1px solid Black;">
 class VM
:	def fetch(self)
:		assert self.D ; addr = self.D.pop(
)		assert addr&lt;  len(self.program
)		self.D.append(self.program[addr]
)	def store(self)
</pre>  <code>LIT</code>: command is required to <b>push constants</b>  as is on data stack <pre style="border:1px solid Black;">
:	def lit(self)
:		self.D.append(self.program[self.Ip]
)		self.Ip += 
1	def log_command(self,addr)
:		if command in [ VM.jmp, VM.qjmp, VM.call, VM.lit]
</pre> <pre style="border:1px solid Black;">
:class FORTH(VM)
:	cmd = { .., '@':VM.fetch, '!':VM.store , 'lit':VM.lit} 	
</pre>
 <pre style="border:1px solid Black;">
	class FORTH(VM)
:	tokens = [..,'VAR','FETCH','STORE'
] 	def t_VAR(self,t)
: 		r'var
' 		return 
t 	def t_FETCH(self,t)
: 		r'@
' 		return 
t 	def t_STORE(self,t)
: 		r'!
' 		return 
</pre> tWe can implement more complex number literals including hex, binary an dint/float numbers :<pre style="border:1px solid Black;">
 	tokens = [..,'NUM',..
] 	def t_NUM(self,t)
:		r'0x[0-9A-Fa-f]+
|			0b[01]+
|			[\+\-]?[0-9]+(\.[0-9]*)?([eE][\+\-]?[0-9]+)?
'  		if t.value[:2] == '0x'
:  			t.value = int(t.value[2:],0x10) # he
x  		elif t.value[:2] == '0b'
:  			t.value = int(t.value[2:],0x02) # bi
n  		else
:  			t.value = float(t.value
) 		return 
t 	def t_ID(self,t): # this rule must be last rul
</pre>
<pre style="border:1px solid Black;">
eclass FORTH(VM)
: 	def p_VAR(self,p)
: 		' command : init VAR ID 
' 		addr = len(self.program
) 		self.voc[p[3]] = addr ; self.revoc[addr] = p[3
] 		# lit PF
A 		self.program.append(self.cmd['lit'])	 # lit ..
. 		self.program.append(len(self.program)+2) # PF
A 		# re
t 		self.program.append(self.cmd['ret']
) 		# compile PFA with init valu
e 		self.program.append(p[1]
) 	def p_FETCH(self,p)
: 		' command : FETCH 
' 		self.program.append(self.cmd['@']
) 	def p_STORE(self,p)
: 		' command : STORE 
' 		self.program.append(self.cmd['!']
) 	# var/const init value can be checked by syntax parse
r 	def p_init_NUM(self,p)
: 		' init : NUM 
' 		p[0] = p[1
] 	def p_init_bool(self,p)
: 		' init : bool 
' 		p[0] = p[1
] 	def p_bool_true(self,p)
: 		' bool : TRUE 
' 		p[0] = Tru
e 	def p_bool_false(self,p)
: 		' bool : FALSE 
' 		p[0] = Fals
</pre>
e ]


<!-- GUI.tex -->

<H1>GUI application in TaskBar</H1><A NAME="21"><H1>Mobile-targetted GUI</H1><A NAME="22">
You can make \ Fwork in text console mode, but we think mobile, so we jum
pstart from GUI interface, tuned for smartphone look\&feel. We must be ready t
oface up with one thumb interface with vertical screen covered by hal
fwith Android keyboard starting from scratch of Skynet development. You must b
eable to do something cool with one hand doing Vrschikasana in crowded bus

.For fast start we will use wxWidgets [<a href="#zetwx">zetwx</a>]   toolkit
,but later wil
lmove to native GUI to make system must lighter and closer to native hos
tplatform

<pre style="border:1px solid Black;">
.import wx					# import wxWidget
swxapp = wx.App()			# create wx GUI applicatio
nwxmain = wx.Frame(None,-1,sys.argv[0])	# ?,?,window titl
ewxmain.Show()				# set visibl
ewxapp.MainLoop()			# start wx GUI main loo
</pre>
p\fig{gui00.png}{height=0.7\textheight
}To take this screenshot we must make GUI work in parallel thread <pre style="border:1px solid Black;">
:import threadin

gwxapp = wx.App()		# create wx GUI applicatio
ndef startGUI():				# wrap thread in functio
n	global wxmain			# required for ScreenShot(
)	wxmain = wx.Frame(None,-1,sys.argv[0]
)	wxmain.Show()			# set visibl
e	wxapp.MainLoop()		# start wx GUI main loo
pthGUI = threading.Thread(None,startGUI
)thGUI.start()				# start GUI threa

ddef ScreenShot(PNG)
:	dc = wx.ScreenDC(
)	X,Y,W,H = wxmain.GetRect(
)	bmp = wx.EmptyBitmap(W,H
)	mdc = wx.MemoryDC(bmp
)	mdc.Blit(0,0,W,H,dc,X,Y
)	bmp.SaveFile(PNG,wx.BITMAP_TYPE_PNG

)# wait until GUI starts, and do screensho
ttime.sleep(1) ; ScreenShot('sshot.png'

)# do all non-GUI work here as VM(program) ru

nthGUI.join()				# wait until GUI stop
</pre>
sTune size to make GUI looks like messenger in right down corner of screen <pre style="border:1px solid Black;">
:	# tune size and position to look like messenge
r	X,Y,W,H = wx.ClientDisplayRect(
)	# create main fram
e	wxmain = wx.Frame(None,-1,sys.argv[0]
,		size=(W/4,H/2),pos=(W-W/4,H-H/2)
</pre>
<H1>TaskBar</H1><A NAME="23">
)It is cool to have cool tool in taskbar, so we can make it  <A HREF="http://www.blog.pythonlibrary.org/2013/07/12/wxpython-how-to-minimize-to-system-tray/">here you can found details</A>, .Taskbared GUI application require TaskBarIcon handler, wrapped in custom class <pre style="border:1px solid Black;">
:# taskbar manage
rclass TaskBar(wx.TaskBarIcon):
		def __init__(self,frame)
:		# init superclas
s		wx.TaskBarIcon.__init__(self
)		# save frame we manag
e		self.frame = fram
e		# set taskbar ico
n		self.icon = frame.ico
n		self.SetIcon(self.icon,sys.argv[0]
)		# bind open/focus on left clic
k		self.Bind(wx.EVT_TASKBAR_LEFT_DOWN
,			self.OnTaskBarLeftClick
)	def OnTaskBarActivate(self,event)
:		pas
s	def OnTaskBarClose(self,event)
:		self.frame.Close(
)	def OnTaskBarLeftClick(self,event)
:		self.frame.Show()		# show fram
e		self.frame.Restore()	# un(min|max)imiz
e		self.frame.Raise()		# make top level windo
w		self.frame.SetFocus()	# and set focu
</pre> sand to be consistent, wrap main frame into class too <pre style="border:1px solid Black;">
:class MainWindow(wx.Frame): # main GUI window in clas
s	def __init__(self)
:		# tune size and position to look like messenge
r		X,Y,W,H = wx.ClientDisplayRect(
)		# create main fram
e		wx.Frame.__init__(self,None,-1,sys.argv[0]
,		size=(W/4,H/2),pos=(W-W/4,H-H/2)
)		# style tun
e		self.icon = wx.ArtProvider.GetIcon
(			wx.ART_ADD_BOOKMARK
)		self.SetIcon(self.icon
)		self.SetBackgroundColour(wx.BLACK
)		# set visibl
e		self.Show(
)		# make GUI taskbare
d		self.tbIcon = TaskBar(self
)	def onClose(self,event)
:		# required to remove taskbar ico
n		self.tbIcon.RemoveIcon(
)		self.tbIcon.Destroy(
)		# destroy main window itsel
f		self.Destroy(
</pre> )We still need function to wrap GUI in separate thread, but it become svery simple <pre style="border:1px solid Black;">
:def startGUI():				# wrap thread in functio
n	global wxmain			# required for ScreenShot(
)	wxmain = MainWindow()	# construct main windo
w	wxapp.MainLoop()		# start wx GUI main loo
pthGUI = threading.Thread(None,startGUI
)thGUI.start()				# start GUI threa
</pre> dAs option you can do screenshots <pre style="border:1px solid Black;">
:class MainWindow(wx.Frame): # main GUI window in clas
s	def shot(self,PNG='sshot.png'):	# do screen sho
t		dc = wx.ScreenDC(
)		X,Y,W,H = self.GetRect(
)		bmp = wx.EmptyBitmap(W,H
)		mdc = wx.MemoryDC(bmp
)		mdc.Blit(0,0,W,H,dc,X,Y
)		bmp.SaveFile(PNG,wx.BITMAP_TYPE_PNG

)time.sleep(1) ; wxmain.shot(
</pre> )


<!-- calc.tex -->

<H1>Parsing in \cpp: simple calculator</H1><A NAME="24">If you don't interested in low-level programming in \cpp, please skip thi
schapter. But if you know C++ a bit, look at this theme much closer: flex/biso
nis cool tools lets you do lot of things looks very complex on first glance
<ul>
<li> :[process any data in text format], like config files and data for you
rprograms, it is very suitable to have this data in human readable for
<li> m[process complex command line]: pack <code>argv[]</code>  into one string an
dinterpret it as scrip
<li> t[process source code], you can make syntax colorer writes into .html files
,in few lines, using only flex
</ul>

.In this chapter, we'll see how to implement simple calculator \textit{with infi
xsyntax} and variables, works in console. It is a quite useful program
,especially if your job coupled with engineering or science. I myself constantl
yuse it making some CADding and in occasionally everyday use

.In next sections, we'll see how to add some very complex in fact theme
 <b>user-defined functions</b>:, some control constructions, and arrays

<p>
.You can download full source code from separate github repo
 <A HREF="http://github.com/ponyatov/calc">http://github.com/ponyatov/calc</A>:, an
d\href{http://github.com/ponyatov/calc/releases/latest}{prebuild window
sbinary} for first try

<H1>skelex: lexical program project skeleton</H1><A NAME="25">

.First, we'll see how to organize our tiny project
<p>

.Nowdays you use huge IDE for software development, but I prefer more light
,portable and easy way: I use (g)vim /<A HREF="#vim"><sup>vim</sup></A>/  text editor and Makefile\note{an
dEclipse for more complex cases}. Vim has strange key bindings, and can be som
ecryptic for a newbie, but is very light in resources and have useful synta
xcoloring customization described in details in vim syntax colorin
 /<A HREF="#vimcolor"><sup>vimcolor</sup></A>/g

<p>
.\begin{tabular}{l l l
}src.src & script & sample source code<br>
 log.log & & execution log<br>
 ypp.ypp & yacc & syntax parser<br>
 lpp.lpp & lex & lexer using regexps<br>
 hpp.hpp & \cpp & headers<br>
 cpp.cpp & \cpp & runtime system we are going to implement<br>
 Makefile & make & project build script<br>
 rc.rc & linux & (g)vim start helper<br>
 bat.bat & windows & (g)vim start helper<br>
 .gitignore & git & ignored file masks<br>
 ftdetect.vim & vim & file type detection<br>
 syntax.vim & vim & syntax coloring /<A HREF="#vimcolor"><sup>vimcolor</sup></A>/  for custom script<br>
 \end{tabular

<pre style="border:1px solid Black;">
}#!/bin/s
hgvim -p src.src log.log  				ypp.ypp lpp.lpp hpp.hpp cpp.cpp Makefil
</pre>
e\subsection{Makefile: build script
}For project build, you need to <b>track file interdependency</b>  and do som eactions <b>only on changed files</b> . So we can describe out dependency/actio nrules in tiny Makefile, and run make tool by hotkey in editor every time we nee dto compile or run project. Consult Addendum: GNU Make /<A HREF="#make"><sup>make</sup></A>/  for details ,here we see only tiny Makefile snippet
<pre  style="border:1px solid Black;">log.log: src.src ./exe.exe
	/exe.exe < $< > $@ && tail $(TAIL) $@
C = cpp.cpp ypp.tab.cpp lex.yy.c
H = hpp.hpp ypp.tab.hpp lex.yy.h
L = -lreadline
./exe.exe: $(C) $(H)
	(CXX) $(CXXFLAGS) -o $@ $(C) $(L)
ypp.tab.cpp ypp.tab.hpp: ypp.ypp
	bison $<
lex.yy.c lex.yy.h: lpp.lpp
	flex $<
</pre>
<H1>lex: lexer generator</H1><A NAME="26">
.Lexer and parser files use same header with <code>#include <headers></code>  <pre style="border:1px solid Black;">

:#include "hpp.hpp

</pre> "Lexer file <b>must end with empty line</b> , don't forget to place EOL in las tstring <pre style="border:1px solid Black;">

.#include "hpp.hpp

</pre>
"Another <b>required</b>  section is rules, but for fist time it can be empty <pre style="border:1px solid Black;">

</pre>
:Now you can run flex, and get resulting generated lexer source in lex.yy.c file <pre style="border:1px solid Black;">
:&gt;$ flex lpp.lpp && ls -la lex
*-rw-r--r-- 1 ponyatov ponyatov 43935 nov 20 19:43 lex.yy.
</pre> cAnd we have a problem: there is no <code>lex.yy.h</code>  header file, contain  <code>yylex()</code>s and <code>yy_scan_string()</code>  function declaration we required t oparse every string, entered in interactive command line\note{using readlin elibrary}. To fix it, we must add option will create header file for as
<H1>yacc: parser generator</H1><A NAME="27"> .


<!-- pypy.tex -->

<H1>It's time to do a PyPy</H1><A NAME="28">



<!-- LLVM.tex -->

<H1>Using LLVM</H1><A NAME="29">The <A HREF="http://llvm.org/">LLVM Project</A> \note{Low Level Virtual Machine} is 
acollection of modular and reusable compiler and toolchain technologies. Despit
eits name, LLVM has little to do with traditional virtual machines. Project goa
lwas providing a modern, SSA\note{In compiler design, static single assignmen
tform (often abbreviated as SSA form or simply SSA) is a property of a
nintermediate representation (IR), which requires that each variable is assigne
dexactly once, and every variable is defined before it is used.}-based /<A HREF="#SSA"><sup>SSA</sup></A>/
 compilation strategy capable of supporting both static and dynamic compilatio
nof arbitrary programming languages. The primary sub-projects of LLVM are
<ul>
<li> :[LLVM Core] libraries provide a modern source- and target-independen
 <b>optimizer</b>t, along with <b>code generation</b>  support for many popula
rCPU
<li> s[Clang] is C/\cpp/Objective-C compile
<li> r[LLDB] builds on libraries provided by LLVM and Clang to provide 
 <b>debugger</b>a
</ul>

<p>
 <A HREF="http://www.llvmpy.org/">llvmpy</A>. is a Python wrapper around the LLVM \cp plibrary which allows simple access to compiler tools
.It can be used for a lot of things, but here are some ideas
<ul>
: <li>  
 dynamically create LLVM IR for linking with LLVM IR produced by <code>CLANG</code>  o
 <code>dragonegg</code>
r <li>  
 build machine code dynamically using LLVM execution engin
e <li>  
 use together with PLY or other tokenizer and parser to write a complete compile
rin \p
</ul>

<H1>Installation</H1><A NAME="30">

y\begin{verbatim
}$ sudo apt install python-llvm python-pl
yo
r$ sudo pip install llvmpy pl
y\end{verbatim
<pre  style="border:1px solid Black;">import llvm ; llvm.test()</pre>

}Tiny executable module does nothing, done usin
 <A HREF="https://eli.thegreenplace.net/2012/08/10/building-and-using-llvmpy-a-basic-example">this manual</A>g
<pre  style="border:1px solid Black;">import llvm.core	# core library
import llvm.ee		# execution engine (JIT/interpreter)

module = llvm.core.Module.new('null_module') ; print module
# JIT compiler / interpreter
engine = llvm.ee.ExecutionEngine.new(module) ; print engine
</pre>


<!-- SSA.tex -->

<H1>SSA: Single State Assignment</H1><A NAME="31"><A NAME="SSA">

:


<!-- TUI.tex -->

<H1>TUI: Text User Interface</H1><A NAME="32"><A NAME="TUI">As we are going to use DLR for RealTime control systems /<A HREF="#RT"><sup>RT</sup></A>/ 
 <i>graphics interfaces are not suitable for us</i>,. Even simple graphics lik
etext output <b>require a huge amount of memory</b>  to store window regio
nimages, <b>and a lot of bus time to transfer</b>  (bitblit) this regions. Typica
lPLC or control panel can have tiny text-only LCD with down to short one line an
dfew joystick-like buttons. No large touchscreen, qwerty keyboard or trackbal
ldevices
.
 


<!-- reference.tex -->

<H1>Reference</H1><A NAME="33"><A NAME="reference">
<H1>Core</H1><A NAME="34">
<H1>GUI</H1><A NAME="35">


<!-- parsing.tex -->

<H1>Complex parsing</H1><A NAME="36">

<H1>PEG \& Packrat algorithm</H1><A NAME="37">

<H1>Python tabbed syntax</H1><A NAME="38">

<H1>DCG: Definite Clause Grammar</H1><A NAME="39"><A NAME="DCG"><H1>Binary parsing</H1><A NAME="40">

To decode a lot of complex binary formats and protocols you can use binar
yparser generator described here. You can describe format using special BNF-lik
elanguage, and do syntax triggering technique to do actions on parsed data
.The algorithm used is a special case of DCG /<A HREF="#DCG"><sup>DCG</sup></A>/  tuned for stream parsin
gwith error recovery enabled

.For example, you can use this tool to write protocol parsers for widely know
ngrabbing/decoder software <A HREF="http://www.wireshark.org/">Wireshark</A> ,
 simple disassemblers, and binary data file dumpers
.

<!-- java.tex -->

<H1>Porting to \J\ hell</H1><A NAME="41">

\ Jis an ugly language and technology, but if you want to earn money, it's 
azen way to incorporate your DLR habits into an enterprise hell. We'll be face
dwith huge problems with no prototypes in OOP, scary resource consumptions, an
dcreepy Duke drilling your brain

.\begin{center}\fig{duke.png}{height=0.7\textheight}\end{center

<H1>JVM: \J\ Virtual Machine</H1><A NAME="42">}\ JVirtual Machine, or JVM for short, in fact is some computer emulator
,similar to our DLR VMs. So the right way to dig in is start write programs i
n\J-assembly

<H1>Jasmin assembly</H1><A NAME="43">

 <A HREF="http://jasmin.sourceforge.net/">http://jasmin.sourceforge.net/</A><p>

<H1>Object Model problem: no prototypes anymore</H1><A NAME="44">

<H1>ANTLR</H1><A NAME="45">

<H1>JSR 292: Supporting Dynamically Typed Languages</H1><A NAME="46">.

<!-- Forth.tex -->

<H1>Something different: flat memory FORTH</H1><A NAME="47"><A NAME="forth">

As we see in /<A HREF="#pyforth"><sup>pyforth</sup></A>/ , it is easy to write some \F-like system in fe
whours in any programming language. Manipualting with objects on stack is simple
,and let you use any side libraries and language high level features.
 But if you work with really small computer systems, like custom hardware buil
don Cortex-M microcontroillers, <i>you have very small amount of RAM</i> . Th
etopmost microcontroller family STM32F7 MCU used i
 <A HREF="http://www.st.com/en/evaluation-tools/32f746gdiscovery.html">STM32F7GDISCOVERY</A>
nboard has <b>only 340K of RAM</b> . \textcolor{green}{There is no space to ru
nfat dynamic language runtime with OOP}
.For this narrow case we have \ Fwell known from the end of 70s, and its bi
gbrother OpenFirmware. In this part we'll see how we can implement tin
y\ Fsystem using bytecode approach\note{It can be interesting for you how t
oimplement tiny assembler, without problems caused by concrete machine languag
edetail s--- bytecode simple commands format is very easy to understand. }bu
tlow memory



.In <code>FORTH/</code>  subdirectory you can see sources of bytecode compiler an
dvirtual machine (bytecode interpreter), with assember written i
nflex/bison

<H1>\F\ file structure</H1><A NAME="48">

.\begin{tabular}{l l l
}src.src & assembly-like & \ Fsystem source code<br>
 & syntax <br>
&log.log & & logged execution of<br> &&VM running compiled system<br>
 ypp.ypp & bison & syntax parser<br>
 lpp.lpp & flex & token lexer<br>
 hpp.hpp & \cpp & headers<br>
 cpp.cpp & \cpp & compiler elements and virtual machine<br>
 Makefile & make & build scrip<br>t&&(can be sample for any program use
sflex/bison<br>
)FVM.exe & executable & assembler and virtual machine bundle<br>
 bin.bin & bytecode & compiled \ Fsystem bytecod<br>
e&& dumped after VM executio<br>
n\end{tabular

<H1>Virtual Machine Architecture</H1><A NAME="49">

}FVM\note{\ FVirtual Machine }has one byte-addressed memory, and two separat
estacks
<ul>
<li> :[data stack] for data
<li>  [return stack] return addresses for call/ret command
</ul>

<p>
sSizes of this structures was defined by constants, but you can modify code an
duse expandable storage type like <code>vector</code> \note{it will be much slower

<pre style="border:1px solid Black;">
}#define Msz 0x1000		/* bytes *
/#define Rsz 0x10
0#define Dsz 0x10
</pre>
 \ Fhas special <code>CELL</code>  constant, corresponds to \textit{machine word siz ein bytes}
<pre style="border:1px solid Black;">
.#define CELL sizeof(int32_t
</pre>
)\subsection{Memory
<pre style="border:1px solid Black;">
}extern uint8_t  M[Msz];	// memor
yextern uint32_t Ip=0;	// instruction pointe
rextern uint32_t Cp=0;	// compilation pointer (free heap
</pre>
)Main memory contains all <ul> : <li>   compiled bytecod e <li>   vocabulary structure /<A HREF="#vocabulary"><sup>vocabulary</sup></A>/   <li>   data (constants, variables, strings, binary blobs,\ldots ) <li>   heap from current <code>Cp</code>  till end of <code>M[]</code>  /<A HREF="#Fheap"><sup>Fheap</sup></A>/ </ul>
 Memory has byte adressing, so we need some functions to get/set CELLs
<pre style="border:1px solid Black;">
:extern void set(uint32_t addr, int32_t value)
;extern uint32_t get(uint32_t addr)
</pre>
;If you set <code>cell < 0x100</code>  , but read byte on same address, you must get th esame value. On \term{little-endian} machines (x86) we can read/write cells usin  <code>(uint32_t*)&M[addr]</code>g pointer, but for portability we use thi sbyte-shifting functions
<pre style="border:1px solid Black;">
:void set(uint32_t addr, int32_t value) 
{	assert(addr+3&lt;  Msz);			  // check memory boun
d	M[addr+0] = (valu&gt;&gt;e0x00) & 0xFF
;	M[addr+1] = (valu&gt;&gt;e0x08) & 0xFF
;	M[addr+2] = (valu&gt;&gt;e0x10) & 0xFF
;	M[addr+3] = (valu&gt;&gt;e0x18) & 0xFF;	
</pre> <pre style="border:1px solid Black;">
}uint32_t get(uint32_t addr) 
{	assert(addr+3&lt;  Msz)
;	return  		M[addr+0&lt;&lt;]0x00 | M[addr+1&lt;&lt;]0x08 |  		M[addr+2&lt;&lt;]0x10 | M[addr+3&lt;&lt;]0x18;	
</pre>
}\subsection{Compilation (in terms of \F)
<pre style="border:1px solid Black;">
}extern uint32_t Cp;		// compilation pointer (free heap
</pre>
)In \ Fterm \term{compilation} means \textit{adding bytes to the end o fvocabulary}, in fact into the begin of a heap, moving heap bottom to highe raddresses. In \ Fstandard there is only <code>HERE</code>  word returns address o fthe heap begin (it must be <code>HEAP</code>  name definitely). So to address we'll us especial <code>Cp</code>  register<A NAME="Fheap">
<pre style="border:1px solid Black;">
.extern void Cbyte( uint8_t);	// compile byt
eextern void Ccell(uint32_t);	// compile cel
lextern void Cstring(char*);		// compile ASCIIZ strin
</pre>
gThese functions will be used in assembler <p>
<A NAME="Cxxx"> <pre style="border:1px solid Black;">
.void Cbyte( uint8_t b) 
{	M[Cp++] = b; assert(C&lt;pMsz); 
}void Ccell(uint32_t c) 
{	set(Cp,c); Cp+= CELL; assert(C&lt;pMsz); 
}void Cstring(char* s) 
{	uint32_t L = strlen(s); assert(Cp+L+&lt;1Msz);	// lengt
h	memcpy(&M[Cp],s,L+1); Cp += L+1; }	// compile length+
</pre>
1\subsection{Vocabulary structure<A NAME="vocabulary">
}In \ Fterms \term{word} means some active data element, analogous to functio nand procedure in mainstream languages. Variables and constants in \ Fals owords. It corresponds to \term{word} in human language s--- sequence o fletters, which means something. When you enter some \ Fcode in command line ,interpreter /<A HREF="#INTERPRET"><sup>INTERPRET</sup></A>/  searches each word\note{delimited by space symbols }in \term{vocabulary}, and executes /<A HREF="#EXECUTE"><sup>EXECUTE</sup></A>/  it if search was successful
<p> .\term{Vocabulary} is container data structure, implements <ul> <li> :[words storage] in linked list order\note{or tree of linked lists in cas eof multiple vocabulary supported <li> }[word search] by its nam <li> e[definition] of new words using compiling words (see <code>Cxxx()</code>  functions /<A HREF="#Cxxx"><sup>Cxxx</sup></A>/  </ul>
)Every item in vocabulary has this fields structure\note{If you plan to do som ehacking using bytecode for software writing, you can eliminate vocabular yheaders in case of you do not use vocabulary search. To do this, you ca nfork your own assembler, and remove all calls in Cheader() except CFA(). CF Acompilation is required because it sets \_entry field in first jmp command t olast defined word (see next page).}
<p>:\begin{tabular}{l l l l }LFA & cell & Link Field Area & link to previous word or 0<br>  AFA & byte & Attribute Field Area & flags, IMMED /<A HREF="#IMMEDIATE"><sup>IMMEDIATE</sup></A>/ <br>  NFA & asciiz string & Name Field Area & word name<br>  CFA & bytecode & Code Field Area & executable bytecode<br>  PFA & optional & Parameters Field Area & in variables and constants<br>  \end{tabular }Last defined word must be marked somewher <ul> e <li>    as entry point on system start, an d <li>    as first point in search and compilation, </ul>  so we need special fields in the beginning of memory image
<pre style="border:1px solid Black;">
:// program entry point (addr of jmp parameter
)#define _entry  
1// last defined word LFA addres
s#define _latest (_entry+CELL

)int main(int argc, char *argv[]) 
{	// ============ compile vocabulary heade
r	// jmp _entry	jump to last defined wor
d	Cbyte(opJMP); Ccell(0)
;	// _latest		LFA of last defined wor
d	Ccell(0)
</pre>
;To compile vocabular header us <pre style="border:1px solid Black;">
ema&lt;pstring,uint32_&gt;t SymTable;				// symbol tabl

evoid LFA() 
{	uint32_t L = get(_latest); set(_latest,Cp); Ccell(L); 
}void AFA(uint8_t b) {
 	Cbyte(b); 
}void NFA(char* s) {
 	Cstring(s); 
}void CFA(string name) {
 	SymTable[name] = Cp; set(_entry,Cp); 
}void Cheader(char* name) {				  // compile heade
r	LFA(); AFA(); NFA(name); CFA(name); 
</pre>
}\subsection{Bytecode interpreter
}Bytecode interpreter will be run after assembler ended its work
<pre style="border:1px solid Black;">
:int main() 
{	...						// compile vocabulary heade
r	yyparse();				// run compile
r	dump();					// dump memory into .bin fil
e	VM();					// run V
M}
</pre>
	As any other computer, interpreter implements fetch/decode/execute loop ove rcommands in <code>M[]</code>  memory, with command pointed by <code>Ip</code>  instructio npointer register
<pre style="border:1px solid Black;">
.void VM() { for (;;) {						// infty loo
p	printf(
"	uint8_t op = M[Ip++]; assert(I&lt;p=Cp);		 // FETC
H	printf(
"	switch (op) {						// DECODE/EXECUT
E		case opNOP : nop();  break
;		case opBYE : bye();  break
;		case opJMP : jmp();  break
;		case opCALL: call(); break
;		case opRET : ret();  break
;		case opLIT : lit();  break
;		default
:			printf("bad opcode\n\n"); abort()
;	
}	printf("\n")
;}
</pre>
<H1>Core command set</H1><A NAME="50">
}FVM uses two bytecode command types <ul> <li> :[CMD0] one byte opcode without parameter <li> s[CMD1] byte opcode with required cell-sized paramete </ul>
<pre style="border:1px solid Black;">


</pre>
r\subsection{Control flow
<pre style="border:1px solid Black;">
}#define opNOP	0x00	// no
p#define opBYE	0xFF	// by
e#define opJMP	0x01	// jmp&lt; add&gt;
r#define opQJMP	0x02	// ?jmp&lt; add&gt;
r#define opCALL	0x03	// call&lt; add&gt;
r#define opRET	0x04	// re
t#define opLIT	0x05	// lit&lt; valu&gt;
</pre>
<ul>
<li> e[nop] do nothin <pre style="border:1px solid Black;">
g#define opNOP	0x00	// no
</pre> <pre style="border:1px solid Black;">
pvoid nop() { printf("nop"); 
</pre>
</ul>
}\subsection{Stack manipulations }\subsection{Arithmetics and binary operations }\subsection{Basic input/output (console, files) }\subsection{Fast Foreign Interface
<H1>Extensions</H1><A NAME="51"> }\subsection{Native GUI }\subsection{Networking }\subsection{Database connection
<H1>Media and gaming</H1><A NAME="52"> }\subsection{Simple Direct Layer }\subsection{OpenGL }\subsection{Media codecs
<H1>CAD/CAD/CAE and numerical math</H1><A NAME="53"> }\subsection{Vector schematics }\subsection{EDA Electronics Design }\subsection{Numerical math }\subsection{Vizualization
<H1>Compiler framework</H1><A NAME="54"> }\subsection{Parser generator }\subsection{LLVM }

<!-- PLC.tex -->

<H1>IEC 61131 PLC control stack</H1><A NAME="55">

<H1>RealTime control</H1><A NAME="56"><A NAME="RT">

<H1>Hard and Soft realtime</H1><A NAME="57">

<H1>IEC languages implementation</H1><A NAME="58">

<H1>IL: Instruction List</H1><A NAME="59">

<H1>ST: Structured Text</H1><A NAME="60">



<!-- vim.tex -->

<H1>(g)Vim text editor</H1><A NAME="61"><A NAME="vim">

<H1>key bindings</H1><A NAME="62"><A NAME="vimkeys">

<H1>vim syntax coloring</H1><A NAME="63"><A NAME="vimcolor">


<!-- bib.tex -->

<ul><li style="margin-bottom: 10px;"><a name="PLAI">[<a href="#PLAI">PLAI</a>]  PLA<br>
IShriram Krishnamurth<br>
 <b>Programming Languages: Application and Interpretation</b><br>
 <A HREF="http://cs.brown.edu/~sk/Publications/Books/ProgLangs/">http://cs.brown.edu/~sk/Publications/Books/ProgLangs/</A>

<li style="margin-bottom: 10px;"><a name="dragon">[<a href="#dragon">dragon</a>] i Dragon boo<br>
kAlfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullma<br>
 <b>Compilers: Principles, Techniques, and Tools</b>n second editio

<li style="margin-bottom: 10px;"><a name="bluebook">[<a href="#bluebook">bluebook</a>] n BlueBoo<br>
kAdele Goldberg and David Robso<br>
 <b>Smalltalk-80: The Language and Its Implementation</b><br>
 <A HREF="http://www.mirandabanda.org/bluebook/">http://www.mirandabanda.org/bluebook/</A><br>
nfull pdf: <A HREF="http://sdmeta.gforge.inria.fr/FreeBooks/BlueBook/">http://sdmeta.gforge.inria.fr/FreeBooks/BlueBook/</A>

<li style="margin-bottom: 10px;"><a name="kim">[<a href="#kim">kim</a>] 
 Kim Thoma<br>splaylists on writing flex/bison parsers and script languages<br>
 <code>https://www.youtube.com/playlist?</code><br>
<ul>
<li> :[How to build, install Bison, Flex, Cygwin on Windows <br>
 <A HREF="https://www.youtube.com/playlist?list=PL1\_C6uWTeBDEcJxs3Rz5zjm1gf9YLRDW8">list=PL1\_C6uWTeBDEcJxs3Rz5zjm1gf9YLRDW8</A>
<li> ][
</ul>

<li style="margin-bottom: 10px;"><a name="starting">[<a href="#starting">starting</a>] ] <b>Starting \F</b>  \copyrigh tLeo Brodi<br>
 <A HREF="http://www.forth.com/starting-forth/">http://www.forth.com/starting-forth/</A><br>
 <A HREF="ftp://ftp.apple.asimov.net/pub/apple_II/documentation/programming/forth/Starting%20Forth.pdf">pdf</A>

<li style="margin-bottom: 10px;"><a name="ans94">[<a href="#ans94">ans94</a>] e ANSI X3.215-199<br>
 <b>Programming Languages\ --- Forth</b><br>
4American National Standard for Information System<br>
spdf: <A HREF="https://www.openfirmware.info/data/docs/dpans94.pdf">https://www.openfirmware.info/data/docs/dpans94.pdf</A>

<li style="margin-bottom: 10px;"><a name="threaded">[<a href="#threaded">threaded</a>]   \emph{Threaded Interpretive Languages: Their Design an
dImplementation<br>} R. G. Loeliger<br>
 <A HREF="http://sinclairql.speccy.org/archivo/docs/books/Threaded_interpretive_languages.pdf">pdf</A>

<li style="margin-bottom: 10px;"><a name="thbell">[<a href="#thbell">thbell</a>]   <b>Threaded Code</b>  \copyrigh tJames R. Bel<br>
lpdf: <A HREF="http://home.claranet.nl/users/mhx/Forth_Bell.pdf">http://home.claranet.nl/users/mhx/Forth_Bell.pdf</A>

<li style="margin-bottom: 10px;"><a name="crafting">[<a href="#crafting">crafting</a>]   Crafting Interpreter<br>
 <b>A handbook for making programming languages</b><br>
 <A HREF="http://www.craftinginterpreters.com/">http://www.craftinginterpreters.com/</A>

<li style="margin-bottom: 10px;"><a name="zetwx">[<a href="#zetwx">zetwx</a>] s <b>wx\py\ tutorial</b>  \copyrigh tZetCod<br>
e <A HREF="http://zetcode.com/wxpython/">http://zetcode.com/wxpython/</A>

<li style="margin-bottom: 10px;"><a name="atc">[<a href="#atc">atc</a>] 	 <b>Above the Clouds: A Berkeley View of Cloud Computing</b> <br>
 <A HREF="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-28.pdf">EECS-2009-28.pdf</A>

<li style="margin-bottom: 10px;"><a name="beyond">[<a href="#beyond">beyond</a>]   \emph{Beyond Java: A Java Programmers Guide to Assemble
rLanguage<br>
}Stephan Rau
 <A HREF="http://www.beyondjava.net/blog/java-programmers-guide-assembler-language/">blog</A>h


</ul> 


.</BODY></HTML>
